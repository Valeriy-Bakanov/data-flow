#define TEST_PRINT  /* тестовая печать */ \
/*
t_printf( "\n-=- Выполнившаяся инструкция (i_Set): #%d [%s %s,%s,%s(%f),|%s|]  {%d/%d/%d|%d/%d/%d}\n\
-=- Зависимая инструкция    (i/Rule): #%d/%d [%s %s,%s,%s,|%s|]  {%d/%d/%d/%d|%d/%d}\n",\
i_Set, \
Mem_Instruction[i_Set].Set, Mem_Instruction[i_Set].aOp1, Mem_Instruction[i_Set].aOp2, \
aResult, Result, Mem_Instruction[i_Set].aPredicat, \
  Mem_Instruction[i_Set].fPredicat, Mem_Instruction[i_Set].fPredicat_TRUE,  Mem_Instruction[i_Set].fSpeculateExec, \
  Mem_Instruction[i_Set].fExec, Mem_Instruction[i_Set].fExecOut, Mem_Instruction[i_Set].fAddBuffer, \
i, Rule, \
Mem_Instruction[i].Set, Mem_Instruction[i].aOp1, Mem_Instruction[i].aOp2, Mem_Instruction[i].aResult, \
  Mem_Instruction[i].aPredicat, \
  flagNot,flagPredicat,flagPredicat_TRUE, SpeculateExec, \
  Mem_Instruction[i].fPredicat_TRUE, Mem_Instruction[i].fSpeculateExec );
*/
#define DO_OPS_2( i, Rule ) /* вариант 2-х операндов в инструкции */ \
if( Ready_Op1 ) { \
 Mem_Instruction[i].fOp1 = true; \
 snprintf(tmp,sizeof(tmp), " #%d/%d(1|2)", i,Rule); strcat(strInfoLine, tmp); } \
/**********/ \
if( Ready_Op2 ) { \
 Mem_Instruction[i].fOp2 = true; \
 snprintf(tmp,sizeof(tmp), " #%d/%d(2|2)", i,Rule); strcat(strInfoLine, tmp); } \
/**********/ \
if( Mem_Instruction[i].fOp1 && Mem_Instruction[i].fOp2 ) { \
 snprintf(tmp,sizeof(tmp), " #%d/%d(*|2)", i,Rule); strcat(strInfoLine, tmp); }
//
#define DO_OPS_1( i, Rule ) /* вариант 1-го операнда в инструкции */ \
if( Ready_Op1 ) { \
 Mem_Instruction[i].fOp1 = true; \
 snprintf(tmp,sizeof(tmp), " #%d/%d(1|1)", i,Rule); strcat(strInfoLine, tmp); \
 snprintf(tmp,sizeof(tmp), " #%d/%d(*|2)", i,Rule); strcat(strInfoLine, tmp); }
//
#define TURN_ON_FP_TRUE( i ) /* включить бит для индикации цветом истинности флага-ПРЕДИКАТА */ \
if( flagPredicat_TRUE ) \
 Mem_Instruction[i].fPredicat_TRUE = true;  // установим бит флаг-ПРЕДИКАТ для индикации цветом
//
#define TURN_ON_FSPEC_EXEC_2( i ) /* установить бит режима спекулятивного выполнения (2 операнда)  */ \
if( Mem_Instruction[i].fOp1 && Mem_Instruction[i].fOp2 && /* по флагам готовности 1-й и 2-й операнды ГОТОВЫ */ \
   !flagPredicat_TRUE ) /* однако флаг-ПРЕДИКАТ сбрОшен... */ \
 Mem_Instruction[i].fSpeculateExec = true;
//
#define TURN_ON_FSPEC_EXEC_1( i ) /* установить бит режима спекулятивного выполнения (1 операнд)  */ \
if( Mem_Instruction[i].fOp1 && /* по флагам готовности 1-й операнда ГОТОВЫ */ \
   !flagPredicat_TRUE ) /* однако флаг-ПРЕДИКАТ сбрОшен... */ \
 Mem_Instruction[i].fSpeculateExec = true;
//
//
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall
Finalize_Only_SET( INT i_Set )
{ // выполнение инструкции SET номер i_Set !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// предполагается, что это мгновенно (время учитывать не надо)..................
// инструкция SET выполняется НЕ ПРОЦЕССОРОМ, а ВХОДНЫМ коммуникатором !!!
 char Set[_SET_LEN]="\0",
      aResult[_ID_LEN]="\0",
      aPredicat[_ID_LEN]="\0", // поле предиката
      strInfoLine[_4096]="\0", tmp[_512]="\0";
 bool s_isPredicat, // TRUE, если РОДИТЕЛЬСКАЯ (выполнившаяся) инструкция есть ПРЕДИКАТ
      isPredicat, // TRUE, если ЗАВИСИМАЯ инструкция ПРЕДИКАТ
      flagNot, // TRUE, если в ЗАВИСИМОМ операторе первый символ имени флага предиката "!" или "~"
      flagPredicat, // TRUE, если в имени ЗАВИСИМОЙ инструкция есть переменная (XXX или !XXX или ~XXX, где XXX == aResult)
      flagPredicat_TRUE, // TRUE, если в ЗАВИСИМОЙ инструкция флаг предиката TRUE (с учётом isNot)
      Ready_Op1,Ready_Op2 ; // совпадение имён операндов в ЗАВИСИМОЙ инструкция с именем результата в ВЫПОЛНИВШЕМСЯ
 int Rule; //управляющая переменная в переключателу switch()
//
 if( !Regim ) // не выполнять - закончить счет ---------------------------------
  return;
//
 REAL Result = StrToReal( Mem_Instruction[i_Set].aOp1, i_Set ); // запомнили значение 1-го операнда инструкции SET номер i_Set
 strcpy( aResult, Mem_Instruction[i_Set].aResult ); // строка-адрес результата выполненной инструкции
//
// Mem_Instruction[i_Set].fOp1 = true; // у SET всегда 1-й готов!...
//
 s_isPredicat = false; // is_Predicat( Mem_Instruction[i_Set].Set ); // у SET всегда FALSE
//
////////////////////////////////////////////////////////////////////////////////
 Add_toData( i_Set, aResult, Result ); // добавим в Mem_Data[] и для визуализации
////////////////////////////////////////////////////////////////////////////////
//
// установим флаг единократного выполнения SET .................................
//
 Mem_Instruction[i_Set].fExecOut = true; // установили флаг единичного выполнения
 mS->Cells[6][i_Set+1] = Vizu_Flags(i_Set); // визуализировали это в таблице SG_Sets
//
 t_printf( "-I- %s(){1}: инструкция #%d [%s] выполнена (%s) -I-",
            __FUNC__, i_Set, Line_Set(i_Set, 1), Get_Time_asLine());
//
////////////////////////////////////////////////////////////////////////////////
// установим флаг ГОТОВ у ВСЕХ операндов, совпадающих по имени с адресом aResult в пуле инструкций Mem_Sets[i_set]
//
 strcpy(strInfoLine, "\0"); // очистим strInfoLine
//
////////////////////////////////////////////////////////////////////////////////
 for( INT i=0; i<Really_Set; i++ ) // по всему пулу инструкций в Mem_Instruction[]
 {
  strcpy( Set, Mem_Instruction[i].Set ); // ... так удобнее для дальнейшей работы !
  if( is_SET( Set ) ) // это инструкция SET - не обрабатываем ! ---------------
   continue;
//
  strcpy( aPredicat, Mem_Instruction[i].aPredicat ); // будем работать с aPredicat, не изменяя Mem_Instruction[i].aPredicat
//
  isPredicat = is_Predicat( Set ); // TRUE, если ЗАВИСИМАЯ инструкция - ПРЕДИКАТ
//
//--- проверяем, начинается ли имя флага ПРЕДИКАТА с '!' или '~' ...............
  if ( !isPredicat ) // это инструкция - НЕ ПРЕДИКАТ...
   flagNot = ( aPredicat[0] == symbolNot_1 || aPredicat[0] == symbolNot_2 )
               ? true : false; // TRUE, если в поле aPredicat первый символ '!' или '~' (отрицание)
//
//--- проверяем, совпадает ли имя возврашённой переменной с именем -------------
//--- переменной в поле предиката ЗАВИСИМОЙ инструкции -------------------------
  flagPredicat = false;  // начальная установка
  if( !isPredicat &&  // ЗАВИСИМАЯ инструкция - НЕ ПРЕДИКАТ
       strcmp( aPredicat, trueLowerCase  ) && // "и" это НЕ статический true
       strcmp( aPredicat, falseLowerCase ) )  // "и" это НЕ статический false
   if( (  flagNot && !strcmp( &aPredicat[1], aResult ) ) || // флаг-ПРЕДИКАТ отрицается (имя начинается с '!' или '~' )
       ( !flagNot && !strcmp(  aPredicat,    aResult ) ) ) // флаг-ПРЕДИКАТ не отрицаетсяСЯ (имя не нечинается с '!' или '~' )
    flagPredicat = true;
//
//--- теперь определяем значение Result на true или false и окончательно -------
//--- (с учётом статических true/false) устанавливаем flagPredicat_TRUE --------
//
  flagPredicat_TRUE = false; // начальная установка
  if( flagPredicat ) // переменная-предикат определена, но значение ещё неизвестно
   if( ( flagNot && !Result ) || // имя начинается с '!' или '~' и Result==FALSE
      ( !flagNot &&  Result ) ) // имя Не начинается с '!' или '~' и Result==TRUE
    flagPredicat_TRUE = true;
//
//--- отдельно обрабатываем статический true или false -------------------------
  if( !strcmp( aPredicat, trueLowerCase ) ) // если true...
   flagPredicat_TRUE = true;
  if( !strcmp( aPredicat, falseLowerCase ) ) // если false...
   flagPredicat_TRUE = false;
//
  Ready_Op1 = MI_AOP1( i ) ; // флаг готовности операнда 2
  Ready_Op2 = MI_AOP2( i ) ; // флаг готовности операнда 2
//
////////////////////////////////////////////////////////////////////////////////
  switch( Rule=10*Get_CountOperandsByInstruction(Set)+isPredicat )
  {
////////////////////////////////////////////////////////////////////////////////
   case 10: // один операнд; const -> НЕ_ПРЕДИКАТ + (возможно) flag-ПРЕДИКАТ
//
   DO_OPS_1( i, Rule ) // обработка 1-го операнда (из 1-го в инструкции)
//
   TURN_ON_FP_TRUE( i ) // включить бит для индикации цветом истинности флага-ПРЕДИКАТА
//
   TURN_ON_FSPEC_EXEC_1( i ) // установить бит режима спекулятивного выполнения (1 операнд)
//
   TEST_PRINT // отладочная печать
//
   if( MI_FOP1(i) &&  // по флагам готовности 1-й операнд ГОТОВ
     ( ( !SpeculateExec && flagPredicat_TRUE ) || // стандартное выполнение
          SpeculateExec ) ) // спекулятивное выполнение
     Add_toBuffer( i, Rule ); // добавить ГКВ-инструкцию в буфер инстр
//
   break; // конец Rule==10
//
////////////////////////////////////////////////////////////////////////////////
   case 11:  // два операнда; const -> ПРЕДИКАТ
//
   DO_OPS_1( i, Rule ) // обработка 1-го операнда (из 1-го в инструкции)
//
   TEST_PRINT // отладочная печать
//
   if( MI_FOP1(i) ) // флаг готовности у 1-го операнда
    Add_toBuffer( i, Rule ); // добавить ГКВ-команду в буфер команд для исполнения
//
   break; // конец Rule==11
//
////////////////////////////////////////////////////////////////////////////////
   case 20: // два операнда; const -> НЕ_ПРЕДИКАТ + (возможно) flag-ПРЕДИКАТ
//
   DO_OPS_2( i, Rule ) // обработка 2-х операндов (из 2-х в инструкции)
//
   TURN_ON_FP_TRUE( i ) // включить бит для индикации цветом истинности флага-ПРЕДИКАТА
//
   TURN_ON_FSPEC_EXEC_2( i ) // установить бит режима спекулятивного выполнения (2 операнда)
//
   TEST_PRINT // отладочная печать
//
   if( MI_FOP1(i) && MI_FOP2(i) && // по флагам готовности 1-й и 2-й операнды ГОТОВЫ
     ( ( !SpeculateExec && flagPredicat_TRUE ) || // стандартное выполнение
          SpeculateExec ) ) // спекулятивное выполнение
     Add_toBuffer( i, Rule ); // добавить ГКВ-инструкцию в буфер инстр
//
   break; // конец Rule==20
//
////////////////////////////////////////////////////////////////////////////////
   case 21: // два операнда; const -> ПРЕДИКАТ
//
   DO_OPS_2( i, Rule ) // обработка 2-х операндов (из 2-х в инструкции)
//
   TEST_PRINT // отладочная печать
//
   if( MI_FOP1(i) && MI_FOP2(i) ) // флаги готовности у 1-го и 2-го операндов
    Add_toBuffer( i, Rule ); // добавить ГКВ-команду в буфер команд для исполнения
//
   break; // конец Rule==21
//
////////////////////////////////////////////////////////////////////////////////
   default:
//
    t_printf( "\n-E- Некорректное значение i/Rule=%d/%d -E-\n", i,Rule );
//
   break; // других Rule не бывает ---------------------------------------------
////////////////////////////////////////////////////////////////////////////////
//
  } // конец switch по Rule для i-той инструкции -------------------------------
//
////////////////////////////////////////////////////////////////////////////////
//
   mS->Cells[6][i+1] = Vizu_Flags(i); // визуализировали ФЛАГИ данной инструкции
//
  } // конец for( INT i=0; i<Really_Set; i++ ) ---------------------------------
//  
////////////////////////////////////////////////////////////////////////////////
//
  Draw_AllTableInstructions(); // выделение ячеек цветом (будет вызываться при выполнении каждого SET'a )
//
  if( strlen(strInfoLine) ) // если в strInfoLine что-то заносилось...
   t_printf( "-I- %s(){2}: по выполнению инструкции #%d установлены флаги готовности операндов у инструкций: %s -I-",
              __FUNC__, i_Set, strInfoLine);
//
 Already_Exec ++ ; // число уже исполненных инструкций
//
 AttemptExecMaxInstructions_fromBuffer(); // пытаемся выполнить как можно больше ГКВ-инструкций из буфера
// для фактического выполнения инструкций из AttemptExecMaxInstructions_fromBuffer()
// вызывается ExecuteInstructions_Except_SET( i_Set )
//
 Vizu_Flow_Exec(); // визуализация процента исполненных инструкций
//
} // ----- конец Finalize_Only_SET ---------------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall // вызывается для завершения выполнения инструкции на АИУ i_Proc
Finalize_Except_SET( INT i_Proc ) // все операци кроме SET !!!!!!!!!!!!!!!!!!!!!
{ // устанавливаются флаги готовности у входных операндов иных инструкций, зависящих
// по входным операндам от результата выполнения данной на АИУ номер i_Proc
 char Set[_SET_LEN]="\0",
      aResult[_ID_LEN]="\0",
      aPredicat[_ID_LEN]="\0", // поле предиката
      strInfoLine[_4096]="\0", tmp[_256]="\0";
 bool s_isPredicat, // TRUE, если РОДИТЕЛЬСКАЯ (выполнившаяся) инструкция есть ПРЕДИКАТ
      isPredicat, // TRUE, если ЗАВИСИМАЯ инструкция есть ПРЕДИКАТ
      flagNot, // TRUE, если в ЗАВИСИМОЙ инструкции первый символ имени флага-предиката "!" или "~"
      flagPredicat, // TRUE, если в имени ЗАВИСИМОЙ инструкции есть переменная (XXX или !XXX или ~XXX, где XXX == aResult)
      flagPredicat_TRUE, // TRUE, если в ЗАВИСИМОЙ инструкции флаг-предикат TRUE (с учётом isNot)
      Ready_Op1,Ready_Op2 ; // совпадение имён операндов в ЗАВИСИМОЙ инструкции с именем результата в ВЫПОЛНИВШЕМСЯ
  int Rule; //управляющая переменная в переключателу switch()
//
 if( !Regim ) // не выполнять - закончить счет ---------------------------------
  return;
//
 INT i_Set = Mem_Proc[i_Proc].i_Set; // на этом АИУ выполнялась инструкция номер i_Set
//
 REAL Result = Mem_Proc[i_Proc].Result; // значение результата выполненной операции
//
 strcpy( aResult, Mem_Proc[i_Proc].aResult ); // запомнили адрес результата выполнения инструкции i_Set_Result
//
////////////////////////////////////////////////////////////////////////////////
// // при СПЕКУЛЯТИВНОМ выполнении добавлять информацмю в пул данных не нужно !
 if( !( SpeculateExec && Mem_Instruction[i_Set].fSpeculateExec ) )
  Add_toData( i_Set, Mem_Proc[i_Proc].aResult, Result ); // добавить результат выполнившейся инструкции
////////////////////////////////////////////////////////////////////////////////
//
 s_isPredicat = is_Predicat( Mem_Instruction[i_Set].Set ); // TRUE, если выполнившаяся инструкция суть ПРЕДИКАТ
//
 t_printf( "-I- %s(){1}: АИУ #%d выполнило инструкцию #%d [%s] [%d/%d/%d тактов] -I-",
            __FUNC__, i_Proc, i_Set, Line_Set(i_Set, 1),
            Mem_Proc[i_Proc].tick_Start, localTick, localTick - Mem_Proc[i_Proc].tick_Start);
//
 Vizu_Data(); // визуализировать...
//
////////////////////////////////////////////////////////////////////////////////
// добавили запись в набор строк Tpr для анализа загрУженности АИУ..............
 snprintf(strInfoLine,sizeof(strInfoLine), "%10d%10d%10d%10d%10d [%s]",
          i_Proc, Mem_Proc[i_Proc].tick_Start, localTick, localTick - Mem_Proc[i_Proc].tick_Start,
          i_Set, Line_Set(i_Set, 1));
 mTpr->Add(strInfoLine); // добавили строку в список Tpr
//
 strcpy(strInfoLine, "\0"); // очистим strInfoLine для дальнейшего использования
//
 if( SpeculateExec && Mem_Instruction[i_Set].fSpeculateExec ) // СПЕКУЛЯТИВНОЕ выполнение !
  goto cont;
//
//==============================================================================
 for( INT i=0; i<Really_Set; i++ ) // по всем инструкциям из Mem_Instruction[]...
 {
//
  if( i == i_Set ) // кроме только что выполненногй инструкция..................
   continue;
//
  strcpy( Set, Mem_Instruction[i].Set ); // ... так удобнее для дальнейшей работы !
  if( is_SET(Set) ) // инструкция SET уже давно едИножды выполнена !
   continue;
//
  strcpy( aPredicat, Mem_Instruction[i].aPredicat ); // будем работать с aPredicat, не изменяя Mem_Instruction[i].aPredicat
//
  isPredicat = is_Predicat( Set ); // TRUE, если это инструкция ПРЕДИКАТ
//
////////////////////////////////////////////////////////////////////////////////
//
//--- проверяем, начинается ли имя переменной предиката с '!' или '~'
  if ( !isPredicat ) // это инструкция - НЕ предикат
   flagNot = ( aPredicat[0]==symbolNot_1 || aPredicat[0]==symbolNot_2 )
               ? true : false; // TRUE, если в поле aPredicat первый символ '!' или '~'
//
//--- проверяем, совпадает ли имя возврашённой переменной с именем -------------
//--- переменной в поле предиката i-той инструкции -----------------------------
  flagPredicat = false;  // начальная установка
  if( !isPredicat &&  // ЗАВИСИМАЯ инструкция - НЕ ПРЕДИКАТ
       strcmp( aPredicat, trueLowerCase  ) && // "и" это НЕ статический true
       strcmp( aPredicat, falseLowerCase ) )  // "и" это НЕ статический false
   if( (  flagNot && !strcmp( &aPredicat[1], aResult ) ) || // флаг-ПРЕДИКАТ отрицается (имя начинается с '!' или '~' )
       ( !flagNot && !strcmp(  aPredicat,    aResult ) ) ) // флаг-ПРЕДИКАТ не отрицаетсяСЯ (имя не нечинается с '!' ил
    flagPredicat = true;
//
//--- теперь определяем значение Result на true или false и окончательно -------
//--- (с учётом статических true/false) устанавливаем flagPredicat_TRUE --------
//
  flagPredicat_TRUE = false; // начальная установка
  if( flagPredicat ) // переменная-предикат определена, но значение ещё неизвестно
   if( ( flagNot  && !Result ) || // имя начинается с '!' или '~' и Result==FALSE
       ( !flagNot &&  Result ) ) // имя НЕ начинается с '!' или '~' и Result==TRUE
    flagPredicat_TRUE = true;
//
//--- отдельно обрабатываем статический true или false -------------------------
  if( !strcmp( aPredicat, trueLowerCase ) ) // если true...
   flagPredicat_TRUE = true;
  if( !strcmp( aPredicat, falseLowerCase ) ) // если false...
   flagPredicat_TRUE = false;
//
////////////////////////////////////////////////////////////////////////////////
//
  if(Mem_Instruction[i].fExec    || // если инструкция ВЫПОЛНЯЕТСЯ "или"
     Mem_Instruction[i].fExecOut || // уже ВЫПОЛНЕНА "или"
     Mem_Instruction[i].fAddBuffer) // уже ДОБАВЛЕНА В БУФЕР
   continue;
//
  Ready_Op1 = MI_AOP1( i ) ; // флаг готовности операнда 1
  Ready_Op2 = MI_AOP2( i ) ; // флаг готовности операнда 2
//
////////////////////////////////////////////////////////////////////////////////
//
  switch( Rule=100*Get_CountOperandsByInstruction(Set)+10*s_isPredicat+isPredicat )
  {
////////////////////////////////////////////////////////////////////////////////
   case 100: // один операнд; НЕ_ПРЕДИКАТ -> НЕ_ПРЕДИКАТ + (возможно) flag-пПРЕДИКАТ
//
   DO_OPS_1( i, Rule ) // обработка 1-го операнда (из 1-го в инструкции)
//
// TURN_ON_FP_TRUE( i ) - необходимо только для предикатной инструкцией (Rule==110 && Кгду==210)
//
   TURN_ON_FSPEC_EXEC_1( i ) // установить бит режима спекулятивного выполнения (1 операнд)
//
   TEST_PRINT // отладочная печать
//
   if( MI_FOP1(i) && // по флагам готовности 1-й операнд ГОТОВ
     ( ( !SpeculateExec && Mem_Instruction[i].fPredicat_TRUE ) || // стандартное выполнение
          SpeculateExec ) ) // спекулятивное выполнение
     Add_toBuffer( i, Rule ); // добавить ГКВ-инструкцию в буфер инстр
//
   break; // конец Rule==100
//
////////////////////////////////////////////////////////////////////////////////
   case 101: // один операнд; НЕ_ПРЕДИКАИ -> ПРЕДИКАТ
//
   DO_OPS_1( i, Rule ) // обработка 1-го операнда (из 1-го в инструкции)
//
   TEST_PRINT // отладочная печать
//
   if( MI_FOP1(i) ) // флаг готовности у 1-го операнда
    Add_toBuffer( i, Rule ); // добавить ГКВ-команду в буфер команд для исполнения
//
   break; // конец Rule==101
//
////////////////////////////////////////////////////////////////////////////////
   case 110: // один операнд; ПРЕДИКАT -> НЕ_ПРЕДИКАТ + (возможно) flag-ПРЕДИКАТ
//
   DO_OPS_1( i, Rule ) // обработка 1-го операнда (из 1-го в инструкции)
//
   TURN_ON_FP_TRUE( i ) // включить бит для индикации цветом истинности флага-ПРЕДИКАТА
//
   TURN_ON_FSPEC_EXEC_1( i ) // установить бит режима спекулятивного выполнения (1 операнд)
//
   TEST_PRINT // отладочная печать
//
   if( MI_FOP1(i) &&  // по флагам готовности 1-й операнд ГОТОВ
     ( ( !SpeculateExec && Mem_Instruction[i].fPredicat_TRUE ) || // стандартное выполнение
          SpeculateExec ) ) // спекулятивное выполнение
     Add_toBuffer( i, Rule ); // добавить ГКВ-инструкцию в буфер инстр
//
   break; // конец Rule==110
//
////////////////////////////////////////////////////////////////////////////////
   case 111: // один операнд; ПРЕДИКАТ -> ПРЕДИКАТ
//
   DO_OPS_1( i, Rule ) // обработка 1-го операнда (из 1-го в инструкции)
//
   TEST_PRINT // отладочная печать
//
   if( MI_FOP1(i) ) // флаг готовности у 1-го операнда
    Add_toBuffer( i , Rule ); // добавить ГКВ-команду в буфер команд для исполнения
//
   break; // конец Rule==111
//
////////////////////////////////////////////////////////////////////////////////
   case 200: // два операнда; НЕ_ПРЕДИКАТ -> НЕ_ПРЕДИКАТ + (возможно) flag-ПРЕДИКАТ
//
   DO_OPS_2( i, Rule ) // обработка 2-х операндов (из 2-х в инструкции)
//
// TURN_ON_FP_TRUE( i ) - необходимо только для предикатной инструкцией (Rule==110 && Кгду==210)
//
   TEST_PRINT // отладочная печать
//
   if( MI_FOP1(i) && MI_FOP2(i) && // по флагам готовности 1-й и 2-й операнды ГОТОВЫ
     ( ( !SpeculateExec && Mem_Instruction[i].fPredicat_TRUE ) || // стандартное выполнение
          SpeculateExec ) ) // спекулятивное выполнение
     Add_toBuffer( i, Rule ); // добавить ГКВ-инструкцию в буфер команд для выполнения
//
   break; // конец Rule==200
//
////////////////////////////////////////////////////////////////////////////////
   case 201: // два операнда; НЕ_ПРЕДИКАТ -> ПРЕДИКАТ
//
   DO_OPS_2( i, Rule ) // обработка 2-х операндов (из 2-х в инструкции)
//
   TEST_PRINT // отладочная печать
//
   if( MI_FOP1(i) && MI_FOP2(i) ) // флаги готовности у 1-го и 2-го операндов
    Add_toBuffer( i, Rule ); // добавить ГКВ-команду в буфер команд для исполнения
//
   break; // конец Rule==201
//
////////////////////////////////////////////////////////////////////////////////
   case 210: // два операнда; ПРЕДИКАТ -> НЕ_ПРЕДИКАТ + возможно, флаг-ПРЕДИКАТ
//
   DO_OPS_2( i, Rule ) // обработка 2-х операндов (из 2-х в инструкции)
//
   TURN_ON_FP_TRUE( i ) // включить бит для индикации цветом истинности флага-ПРЕДИКАТА
//
   TURN_ON_FSPEC_EXEC_2( i ) // установить бит режима спекулятивного выполнения (2 операнда)
//
   TEST_PRINT // отладочная печать
//
   if( MI_FOP1(i) && MI_FOP2(i) && // по флагам готовности 1-й и 2-й операнды ГОТОВЫ
     ( ( !SpeculateExec && Mem_Instruction[i].fPredicat_TRUE ) || // стандартное выполнение
          SpeculateExec ) ) // спекулятивное выполнение
     Add_toBuffer( i, Rule ); // добавить ГКВ-инструкцию в буфер команд для исполнения
//
   break; // конец Rule==210
//
////////////////////////////////////////////////////////////////////////////////
   case 211: // два операнда; ПРЕДИКАТ -> ПРЕДИКАТ
//
   DO_OPS_2( i, Rule ) // обработка 2-х операндов
//
   TEST_PRINT // отладочная печать
//
   if( MI_FOP1(i) && MI_FOP2(i) ) // флаги готовности у 1-го и 2-го операндов
    Add_toBuffer( i, Rule ); // добавить ГКВ-команду в буфер команд для исполнения
//
   break; // конец Rule==211
//
////////////////////////////////////////////////////////////////////////////////
   default: // других Rule не бывает -------------------------------------------
//
    t_printf( "\n-E- Некорректное значение i/Rule=%d/%d -E-\n", i,Rule );
//
   break;
//
////////////////////////////////////////////////////////////////////////////////
//
  } // конец switch по Rule для i-той инструкция -------------------------------
//
////////////////////////////////////////////////////////////////////////////////
//
   mS->Cells[6][i+1] = Vizu_Flags(i); // визуализировали ФЛАГИ инструкций
//
  } // конец for( INT i=0; i<Really_Set; i++ ) ---------------------------------
//
////////////////////////////////////////////////////////////////////////////////
//
 if( strlen(strInfoLine) ) // если в strInfoLine что-то записывалось...
  t_printf( "-I- %s(){2}: по выполнению инструкции #%d/%d установлены флаги готовности операндов у инструкций: %s -I-",
             __FUNC__, i_Set, i_Proc, strInfoLine);
//
////////////////////////////////////////////////////////////////////////////////
cont: // конец спекулятивного выполнения инсрукций =============================
////////////////////////////////////////////////////////////////////////////////
//
// устанавливаем флаг однократного выполнения инструкции .......................
 Mem_Instruction[i_Set].fExecOut = true; // установили флаг ИНСТРУКЦИЯ_ИСПОЛЬЗОВАНА
// снимаем флаг ИНСТРУКЦИЯ_ВЫПОЛНЯЕТСЯ
 Mem_Instruction[i_Set].fExec    = false; // сняли флаг ИНСТРУКЦИЯ_ВЫПОЛНЯЕТСЯ
//
 Draw_AllTableInstructions(); // выделение ячеек цветом (после .fExecOut ...)
//
////////////////////////////////////////////////////////////////////////////////
//
 Mem_Proc[i_Proc].Busy = false; // АИУ номер i_Proc теперь СВОБОДНО !!! --------
//
 t_printf( "-I- %s(){3}: АИУ #%d освобождено (%s) после выполнения инструкции #%d -I-",
           __FUNC__, i_Proc, Get_Time_asLine(), i_Set);
//
 Free_Proc ++ ; // число свободных АИУ увеличили на 1 ==========================
//
////////////////////////////////////////////////////////////////////////////////
 sleep_for_vizu_buffer // ждем-с для визуализации буфера
////////////////////////////////////////////////////////////////////////////////
 AttemptExecMaxInstructions_fromBuffer(); // пытаемся выполнить как можно больше ГКВ-инструкций из буфера
// для фактического выполнения инструкций из AttemptExecMaxInstructions_fromBuffer()
// вызывается ExecuteInstructions_Except_SET( i_Set )
////////////////////////////////////////////////////////////////////////////////
 sleep_for_vizu_buffer // визуализируем буфер...
////////////////////////////////////////////////////////////////////////////////
//
 Already_Exec ++ ; // число уже испОлненных инструкций
//
 Vizu_Flow_Exec(); // визуализация процента исполненных инструкций
//
} // --- конец Finalize_Except_SET ---------------------------------------------







