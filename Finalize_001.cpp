////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall
Finalize_Only_SET( INT i_Set )
{ // выполнение инструкции SET номер i_Set !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// предполагается, что это мгновенно (время учитывать не надо)..................
// инструкция SET выполняется НЕ ПРОЦЕССОРОМ, а ВХОДНЫМ коммуникатором !!!
 char Set[_SET_LEN]="\0",
      aResult[_ID_LEN]="\0",
      aPredicat[_ID_LEN]="\0", // поле предиката
      strInfoLine[_4096]="\0", tmp[_512]="\0";
 bool s_isPredicat, // TRUE, если ВЫПОЛНИВШАЯСЯ инструкция есть ПРЕДИКАТ
      isPredicat, // TRUE, если ЗАВИСИМАЯ инструкция ПРЕДИКАТ
      flagNot, // TRUE, если в ЗАВИСИМОЙ инструкции первый символ имени флага-предиката "!" или "~"
      flagPredicat, // TRUE, если в имени ЗАВИСИМОЙ инструкция есть переменная (XXX или !XXX)
      flagPredicat_TRUE, // TRUE, если в ЗАВИСИМОЙ инструкция флаг-предикат есть TRUE (с учётом isNot)
      Ready_Op1,Ready_Op2 ; // совпадение имён операндов в ЗАВИСИМОЙ инструкции с именем результата в ВЫПОЛНИВШЕМСЯ
 int Rule; //управляющая переменная в переключателу switch()
//
 if( !Regim ) // не выполнять - закончить счет ---------------------------------
  return;
//
 REAL Result = StrToReal( Mem_Instruction[i_Set].aOp1, i_Set ); // запомнили значение 1-го операнда инструкции SET номер i_Set
 strcpy( aResult, Mem_Instruction[i_Set].aResult ); // строка-адрес результата выполненной инструкции
//
 Mem_Instruction[i_Set].fOp1 = true; // у SET всегда 1-й готов!...
//
 s_isPredicat = false; // is_Predicat( Mem_Instruction[i_Set].Set ); // у SET всегда FALSE
//
////////////////////////////////////////////////////////////////////////////////
 Add_toData( i_Set, aResult, Result ); // добавим в Mem_Data[] и для визуализации
////////////////////////////////////////////////////////////////////////////////
//
// установим флаг единократного выполнения SET .................................
//
 Mem_Instruction[i_Set].fExecOut = true; // установили флаг единичного выполнения
 mS->Cells[6][i_Set+1] = Vizu_Flags(i_Set); // визуализировали это в таблице SG_Sets
//
 t_printf( "-I- %s(){1}: инструкция #%d [%s] выполнена (%s) -I-",
            __FUNC__, i_Set, Line_Set(i_Set, 1), Get_Time_asLine());
//
////////////////////////////////////////////////////////////////////////////////
// установим флаг ГОТОВ у ВСЕХ операндов, совпадающих по имени с адресом aResult в пуле инструкций Mem_Sets[i_set]
//
 strcpy(strInfoLine, "\0"); // очистим strInfoLine
//
////////////////////////////////////////////////////////////////////////////////
 for( INT i=0; i<Really_Set; i++ ) // по всему пулу инструкций в Mem_Instruction[]
 {
  strcpy( Set, Mem_Instruction[i].Set ); // ... так удобнее для дальнейшей работы !
//
  if( is_SET( Set ) ) // это инструкция SET - не обрабатываем ! ---------------
   continue;
//
  strcpy( aPredicat, Mem_Instruction[i].aPredicat ); // будем работать с aPredicat, не изменяя Mem_Instruction[i].aPredicat
//
  isPredicat = is_Predicat( Set ); // TRUE, если ЗАВИСИМАЯ инструкция - ПРЕДИКАТ
//
//--- проверяем, начинается ли имя флага ПРЕДИКАТА с '!' или '~' ...............
  if ( !isPredicat ) // это инструкция - НЕ ПРЕДИКАТ...
   flagNot = ( aPredicat[0] == symbolNot_1 || aPredicat[0] == symbolNot_2 )
               ? true : false; // TRUE, если в поле aPredicat первый символ '!' или '~' (отрицание)
//
//--- проверяем, совпадает ли имя возврашённой переменной с именем -------------
//--- переменной в поле предиката ЗАВИСИМОЙ инструкции -------------------------
  flagPredicat = false;  // начальная установка
  if( !isPredicat &&  // ЗАВИСИМАЯ инструкция - НЕ ПРЕДИКАТ
       strcmp( aPredicat, trueLowerCase  ) && // "и" это НЕ статический true
       strcmp( aPredicat, falseLowerCase ) )  // "и" это НЕ статический false
   if( (  flagNot && !strcmp( &aPredicat[1], aResult ) ) || // флаг-ПРЕДИКАТ отрицается (имя начинается с '!' или '~' )
       ( !flagNot && !strcmp(  aPredicat,    aResult ) ) ) // флаг-ПРЕДИКАТ не отрицаетсяСЯ (имя не нечинается с '!' или '~' )
    flagPredicat = true;
//
//--- теперь определяем значение Result на true или false и окончательно -------
//--- (с учётом статических true/false) устанавливаем flagPredicatTrue ---------
//
  flagPredicat_TRUE = false; // начальная установка
  if( flagPredicat ) // переменная-предикат определена, но значение ещё неизвестно
   if( ( flagNot && !Result ) || // имя начинается с '!' или '~' и Result==FALSE
      ( !flagNot &&  Result ) ) // имя Не начинается с '!' или '~' и Result==TRUE
    flagPredicat_TRUE = true;
//
//--- отдельно обрабатываем статический true или false -------------------------
  if( !strcmp( aPredicat, trueLowerCase ) ) // если true...
   flagPredicat_TRUE = true;
  if( !strcmp( aPredicat, falseLowerCase ) ) // если false...
   flagPredicat_TRUE = false;
//
  Ready_Op1 = MI_aOp1( i ) ; // флаг готовности операнда 2
  Ready_Op2 = MI_aOp2( i ) ; // флаг готовности операнда 2
//
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
  switch( Rule=10*Get_CountOperandsByInstruction(Set)+isPredicat )
  {
////////////////////////////////////////////////////////////////////////////////
   case 10: // один операнд; зависимая инструкция - НЕ ПРЕДИКАТ + (возможно) flag-предикат
//
   do_Ops_1( i, Rule ) // обработка 1-го операнда (из 1-го в инструкции)
//
   turnOn_fP_TRUE( i ) // включить бит для индикации цветом истинности флага-ПРЕДИКАТА
//
   if( MI_fOp1(i) && // первый операнд ГОТОВ...
       flagPredicat_TRUE ) // ... и флаг предиката есть TRUE
    Add_toBuffer( i, Rule ); // добавить ГКВ-команду в буфер команд для исполнения
//
   break; // конец Rule==10
//
////////////////////////////////////////////////////////////////////////////////
   case 11:  // два операнда; зависимая инструкция - ПРЕДИКАТ
//
   do_Ops_1( i, Rule ) // обработка 1-го операнда (из 1-го в инструкции)
//
// завИсимая инструкция суть ПРЕДИКАТНЫй и для него не надо проверять ФЛАГ ПРЕДИКАТАфлаг предиката
   if( MI_fOp1(i) ) // флаг готовности у 1-го операнда
    Add_toBuffer( i, Rule ); // добавить ГКВ-команду в буфер команд для исполнения
//
   break; // конец Rule==11
//
////////////////////////////////////////////////////////////////////////////////
   case 20: // два операнда; зависимая инструкция - НЕ ПРЕДИКАТ + (возможно) flag-предикат
////////////////////////////////////////////////////////////////////////////////
//
   do_Ops_2( i, Rule ) // обработка 2-х операндов (из 2-х в инструкции)
//
   turnOn_fP_TRUE( i ) // включить бит для индикации цветом истинности флага-ПРЕДИКАТА
//
   if( MI_fOp1(i) && MI_fOp2(i) && // флагт готовности у 1-го и 2-го операндов
       flagPredicat_TRUE ) // НЕ ПРЕДИКАТНАЯ инструкция выполняется только при значении ФЛАГА ПРЕДИКАТА = true
    Add_toBuffer( i, Rule ); // добавить ГКВ-команду в буфер команд для исполнения
//
   break; // конец Rule==20
//
////////////////////////////////////////////////////////////////////////////////
   case 21: // два операнда; зависимая инструкция -  ПРЕДИКАТ
//
   do_Ops_2( i, Rule ) // обработка 2-х операндов (из 2-х в инструкции)
//
// завИсимая инструкция суть ПРЕДИКАТНАЯ и для неё не надо проверять флаг-ПРЕДИКАТ
   if( MI_fOp1(i) && MI_fOp2(i) ) // флаги готовности у 1-го и 2-го операндов
    Add_toBuffer( i, Rule ); // добавить ГКВ-команду в буфер команд для исполнения
//
   break; // конец Rule==21
//
////////////////////////////////////////////////////////////////////////////////
   default:
//
    t_printf( "\n-E- Некорректное значение i/Rule=%d/%d -E-\n", i,Rule );
//
   break; // других Rule не бывает ------------------------------------
////////////////////////////////////////////////////////////////////////////////
//
  } // конец switch по Rule для i-той инструкция -------------------------------
//
////////////////////////////////////////////////////////////////////////////////
//
   mS->Cells[6][i+1] = Vizu_Flags(i); // визуализировали ФЛАГИ данной инструкции
//
  } // конец for( INT i=0; i<Really_Set; i++ ) ---------------------------------
//  
////////////////////////////////////////////////////////////////////////////////
//
  Draw_AllTableInstructions(); // выделение ячеек цветом (будет вызываться при выполнении каждого SET'a )
//
  if( strlen(strInfoLine) ) // если в strInfoLine что-то заносилось...
   t_printf( "-I- %s(){2}: по выполнению инструкции #%d установлены флаги готовности операндов у инструкций: %s -I-",
              __FUNC__, i_Set, strInfoLine);
//
////////////////////////////////////////////////////////////////////////////////
 Already_Exec ++ ; // число уже исполненных инструкций
//
 AttemptExecMaxInstructions_fromBuffer(); // пытаемся выполнить как можно больше ГКВ-инструкций из буфера
// для фактического выполнения инструкций из AttemptExecMaxInstructions_fromBuffer()
// вызывается ExecuteInstructions_Except_SET( i_Set )
//
 Vizu_Flow_Exec(); // визуализация процента исполненных инструкций
//
} // ----- конец Finalize_Only_SET ---------------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall // вызывается для завершения выполнения инструкции на АИУ i_Proc
Finalize_Except_SET( INT i_Proc ) // все операци кроме SET !!!!!!!!!!!!!!!!!!!!!
{ // устанавливаются флаги готовности у входных операндов иных инструкций, зависящих
// по входным операндам от результата выполнения данной на АИУ номер i_Proc
 char Set[_SET_LEN]="\0",
      aResult[_ID_LEN]="\0",
      aPredicat[_ID_LEN]="\0", // поле предиката
      strInfoLine[_4096]="\0", tmp[_256]="\0";
 bool s_isPredicat, // TRUE, если ВЫПОЛНИВШАЯСЯ инструкция есть ПРЕДИКАТ
      isPredicat, // TRUE, если ЗАВИСИМАЯ инструкция ПРЕДИКАТ
      flagNot, // TRUE, если в ЗАВИСИМОЙ инструкция первый символ имени флага-предиката "!" или "~"
      flagPredicat, // TRUE, если в имени ЗАВИСИМОЙ инструкции есть переменная (XXX или !XXX)
      flagPredicat_TRUE, // TRUE, если в ЗАВИСИМОЙ инструкция флаг предиката TRUE (с учётом isNot)
      Ready_Op1,Ready_Op2 ; // совпадение имён операндов в ЗАВИСИМОЙ инструкции с именем результата в ВЫПОЛНИВШЕМСЯ
  int Rule; //управляющая переменная в переключателу switch()
//
 if( !Regim ) // не выполнять - закончить счет ---------------------------------
  return;
//
 INT i_Set = Mem_Proc[i_Proc].i_Set; // на этом АИУ выполнялась инструкция номер i_Set
//
 REAL Result = Mem_Proc[i_Proc].Result; // значение результата выполненной операции
//
 strcpy( aResult, Mem_Proc[i_Proc].aResult ); // запомнили адрес результата выполнения инструкции i_Set_Result
//
 s_isPredicat = is_Predicat( Mem_Instruction[i_Set].Set ); // TRUE, если выполнившаяся инструкция суть ПРЕДИКАТ
////////////////////////////////////////////////////////////////////////////////
 Add_toData( i_Set, Mem_Proc[i_Proc].aResult, Result ); // добавить результат выполнившейся инструкции
////////////////////////////////////////////////////////////////////////////////
 t_printf( "-I- %s(){1}: АИУ #%d выполнило инструкцию #%d [%s] [%d/%d/%d тактов] -I-",
            __FUNC__, i_Proc, i_Set, Line_Set(i_Set, 1),
            Mem_Proc[i_Proc].tick_Start, localTick, localTick - Mem_Proc[i_Proc].tick_Start);
//
 Vizu_Data(); // визуализировать...
//
////////////////////////////////////////////////////////////////////////////////
// добавили запись в набор строк Tpr для анализа загруженности АИУ...........
 snprintf(strInfoLine,sizeof(strInfoLine), "%10d%10d%10d%10d%10d [%s]",
          i_Proc, Mem_Proc[i_Proc].tick_Start, localTick, localTick - Mem_Proc[i_Proc].tick_Start,
          i_Set, Line_Set(i_Set, 1));
 mTpr->Add(strInfoLine); // добавили строку в список Tpr
//
////////////////////////////////////////////////////////////////////////////////
//
 strcpy(strInfoLine, "\0"); // очистим strInfoLine
//
//==============================================================================
 for( INT i=0; i<Really_Set; i++ ) // по всем инструкциям из Mem_Instruction[]
 {
//
  if( i == i_Set ) // кроме только что выполненной.............................
   continue;
//
  strcpy( Set, Mem_Instruction[i].Set ); // ... так удобнее для дальнейшей работы !
  if( is_SET(Set) ) // инструкция SET уже давно едИножды выполнена !
   continue;
//
  strcpy( aPredicat, Mem_Instruction[i].aPredicat ); // будем работать с aPredicat, не изменяя Mem_Instruction[i].aPredicat
//
  isPredicat = is_Predicat( Set ); // TRUE, если это инструкция ПРЕДИКАТ
//
////////////////////////////////////////////////////////////////////////////////
//
//--- проверяем, начинается ли имя переменной предиката с '!' или '~'
  if ( !isPredicat ) // это инструкция - НЕ предикат
   flagNot = ( aPredicat[0]==symbolNot_1 || aPredicat[0]==symbolNot_2 )
               ? true : false; // TRUE, если в поле aPredicat первый символ '!' или '~'
//
//--- проверяем, совпадает ли имя возврашённой переменной с именем -------------
//--- переменной в поле предиката i-той инструкции -----------------------------
  flagPredicat = false;  // начальная установка
  if( !isPredicat &&  // ЗАВИСИМАЯ инструкция - НЕ ПРЕДИКАТ
       strcmp( aPredicat, trueLowerCase  ) && // "и" это НЕ статический true
       strcmp( aPredicat, falseLowerCase ) )  // "и" это НЕ статический false
   if( (  flagNot && !strcmp( &aPredicat[1], aResult ) ) || // флаг-ПРЕДИКАТ отрицается (имя начинается с '!' или '~' )
       ( !flagNot && !strcmp(  aPredicat,    aResult ) ) ) // флаг-ПРЕДИКАТ не отрицаетсяСЯ (имя не нечинается с '!' ил
    flagPredicat = true;
//
//--- теперь определяем значение Result на true или false и окончательно -------
//--- (с учётом статических true/false) устанавливаем flagPredicat_TRUE --------
//
  flagPredicat_TRUE = false; // начальная установка
  if( flagPredicat ) // переменная-предикат определена, но значение ещё неизвестно
   if( ( flagNot  && !Result ) || // имя начинается с '!' или '~' и Result==FALSE
       ( !flagNot &&  Result ) ) // имя НЕ начинается с '!' или '~' и Result==TRUE
    flagPredicat_TRUE = true;
//
//--- отдельно обрабатываем статический true или false -------------------------
  if( !strcmp( aPredicat, trueLowerCase ) ) // если true...
   flagPredicat_TRUE = true;
  if( !strcmp( aPredicat, falseLowerCase ) ) // если false...
   flagPredicat_TRUE = false;
//
////////////////////////////////////////////////////////////////////////////////
//
  if(Mem_Instruction[i].fExec    || // если инструкция ВЫПОЛНЯЕТСЯ "или"
     Mem_Instruction[i].fExecOut || // уже ВЫПОЛНЕНА "или"
     Mem_Instruction[i].fAddBuffer) // уже ДОБАВЛЕНА В БУФЕР
   continue;
//
  Ready_Op1 = MI_aOp1( i ) ; // флаг готовности операнда 1
  Ready_Op2 = MI_aOp2( i ) ; // флаг готовности операнда 2
//
////////////////////////////////////////////////////////////////////////////////
//
  switch( Rule=100*Get_CountOperandsByInstruction(Set)+10*s_isPredicat+isPredicat )
  {
////////////////////////////////////////////////////////////////////////////////
   case 100: // один операнд; выполнившаяся инструкция - НЕ ПРЕДИКАИ; зависимыя инструкция - НЕ ПРЕДИКАТ + (возможно) flag-предикат
//
   do_Ops_1( i, Rule ) // обработка 1-го операнда (из 1-го в инструкции)
//
   turnOn_fP_TRUE( i ) // включить бит для индикации цветом истинности флага-ПРЕДИКАТА
//
   if( MI_fOp1(i) && // флаг готовности у 1-го операнда
       flagPredicat_TRUE ) // ... и флаг предиката есть TRUE
    Add_toBuffer( i,  Rule ); // добавить ГКВ-команду в буфер команд для исполнения
//
   break; // конец Rule==100
//
////////////////////////////////////////////////////////////////////////////////
   case 101: // один операнд; выполнившаяся инструкция - НЕ ПРЕДИКАИ; зависимая инструкция - ПРЕДИКАТ
//
   do_Ops_1( i, Rule ) // обработка 1-го операнда (из 1-го в инструкции)
//
   if( MI_fOp1(i) ) // флаг готовности у 1-го операнда
    Add_toBuffer( i, Rule ); // добавить ГКВ-команду в буфер команд для исполнения
//
   break; // конец Rule==101
//
////////////////////////////////////////////////////////////////////////////////
   case 110: // один операнд; выполнившаяся инструкция инструкция - ПРЕДИКАT; зависимая инструкция - НЕ ПРЕДИКАТ + (возможно) flag-предикат
//
   do_Ops_1( i, Rule ) // обработка 1-го операнда (из 1-го в инструкции)
//
   turnOn_fP_TRUE( i ) // включить бит для индикации цветом истинности флага-ПРЕДИКАТА
//
   if( MI_fOp1(i) && // флаг готовности 1-го операнда
       flagPredicat_TRUE ) // ... и ФЛАГ-ПРЕДИКАТ есть TRUE
    Add_toBuffer( i, Rule ); // добавить ГКВ-команду в буфер команд для исполнения
//
   break; // конец Rule==110
//
////////////////////////////////////////////////////////////////////////////////
   case 111: // один операнд; выполнившаяся инструкция - ПРЕДИКАТ; зависимая инструкция - ПРЕДИКАТ
//
   do_Ops_1( i, Rule ) // обработка 1-го операнда (из 1-го в инструкции)
//
   if( MI_fOp1(i) ) // флаг готовности у 1-го операнда
    Add_toBuffer( i , Rule ); // добавить ГКВ-команду в буфер команд для исполнения
//
   break; // конец Rule==111
//
////////////////////////////////////////////////////////////////////////////////
   case 200: // два операнда; выполнившаяся инструкция - НЕ ПРЕДИКАТ; зависимая инструкция - НЕ ПРЕДИКАТ + (возможно) flag-предикат
//
   do_Ops_2( i, Rule ) // обработка 2-х операндов (из 2-х в инструкции)
//
   turnOn_fP_TRUE( i ) // включить бит для индикации цветом истинности флага-ПРЕДИКАТА
//
   if( MI_fOp1(i) && MI_fOp2(i) && // флаги готовности у 1-го и 2-го операндов
       flagPredicat_TRUE ) // ... и флаг предиката есть TRUE
    Add_toBuffer( i, Rule ); // добавить ГКВ-команду в буфер команд для исполнения
//
   break; // конец Rule==200
//
////////////////////////////////////////////////////////////////////////////////
   case 201: // два операнда; выполнившаяся инструкция - НЕ ПРЕДИКАТ; зависимая инструкция - ПРЕДИКАТ
//
   do_Ops_2( i, Rule ) // обработка 2-х операндов (из 2-х в инструкции)
//
   if( MI_fOp1(i) && MI_fOp2(i) ) // флаги готовности у 1-го и 2-го операндов
    Add_toBuffer( i, Rule ); // добавить ГКВ-команду в буфер команд для исполнения
//
   break; // конец Rule==201
//
////////////////////////////////////////////////////////////////////////////////
   case 210: // два операнда; выполнившаяся инструкция - ПРЕДИКАТ; зависимая инструкция - НЕ ПРЕДИКАТ + возможно, флаг-предикат
//
   do_Ops_2( i, Rule ) // обработка 2-х операндов (из 2-х в инструкции)
//
   turnOn_fP_TRUE( i ) // включить бит для индикации цветом истинности флага-ПРЕДИКАТА
//
   if( MI_fOp1(i) && MI_fOp2(i) &&  // по флагам готовности 1-й и 2-й операнды ГОТОВЫ
       flagPredicat_TRUE ) // ... и флаг предиката есть TRUE
    Add_toBuffer( i, Rule ); // добавить ГКВ-команду в буфер команд для исполнения
//
   break; // конец Rule==210
//
////////////////////////////////////////////////////////////////////////////////
// ----- ВЫПОЛНИВШАЯСЯ инструкция - ПРЕДИКАТ && ЗАВИСИМАЯ инструкция - ПРЕДИКАТ (2 операнда) ...
   case 211: // два операнда; выполнившаяся инструкция - ПРЕДИКАТ; зависимая инструкция - ПРЕДИКАТ
//
   do_Ops_2( i, Rule ) // обработка 2-х операндов
//
   if( MI_fOp1(i) && MI_fOp2(i) ) // флаги готовности у 1-го и 2-го операндов
    Add_toBuffer( i, Rule ); // добавить ГКВ-команду в буфер команд для исполнения
//
   break; // конец Rule==211
//
////////////////////////////////////////////////////////////////////////////////
   default: // других Rule не бывает -------------------------------------------
//
    t_printf( "\n-E- Некорректное значение i/Rule=%d/%d -E-\n", i,Rule );
//
   break;
//
////////////////////////////////////////////////////////////////////////////////
//
  } // конец switch по Rule для i-той инструкции -------------------------------
//
////////////////////////////////////////////////////////////////////////////////
//
   mS->Cells[6][i+1] = Vizu_Flags(i); // визуализировали ФЛАГИ инструкций
//
  } // конец for( INT i=0; i<Really_Set; i++ ) ---------------------------------
//
////////////////////////////////////////////////////////////////////////////////
//
 if( strlen(strInfoLine) ) // если в strInfoLine что-то записывалось...
  t_printf( "-I- %s(){2}: по выполнению инструкции #%d/%d установлены флаги готовности операндов у инструкций: %s -I-",
             __FUNC__, i_Set, i_Proc, strInfoLine);
//
////////////////////////////////////////////////////////////////////////////////
// устанавливаем флаг однократного выполнения инструкции .......................
 Mem_Instruction[i_Set].fExecOut = true; // установили флаг ИНСТРУКЦИЯ_ИСПОЛЬЗОВАНА
// снимаем флаг ИНСТРУКЦИЯ_ВЫПОЛНЯЕТСЯ
 Mem_Instruction[i_Set].fExec    = false; // сняли флаг ИНСТРУКЦИЯ_ВЫПОЛНЯЕТСЯ
//
 Draw_AllTableInstructions(); // выделение ячеек цветом (после .fExecOut ...)
//
////////////////////////////////////////////////////////////////////////////////
//
 Mem_Proc[i_Proc].Busy = false; // АИУ номер i_Proc теперь СВОБОДНО !!! --------
//
 t_printf( "-I- %s(){3}: АИУ #%d освобождено (%s) после выполнения инструкции #%d -I-",
           __FUNC__, i_Proc, Get_Time_asLine(), i_Set);
//
 Free_Proc ++ ; // число свободных АИУ увеличили на 1 ==========================
//
////////////////////////////////////////////////////////////////////////////////
 sleep_for_vizu_buffer // ждем-с для визуализации буфера
////////////////////////////////////////////////////////////////////////////////
 AttemptExecMaxInstructions_fromBuffer(); // пытаемся выполнить как можно больше ГКВ-инструкций из буфера
// для фактического выполнения инструкций из AttemptExecMaxInstructions_fromBuffer()
// вызывается ExecuteInstructions_Except_SET( i_Set )
////////////////////////////////////////////////////////////////////////////////
 sleep_for_vizu_buffer // визуализируем буфер...
////////////////////////////////////////////////////////////////////////////////
//
 Already_Exec ++ ; // число уже испОлненных инструкций
//
 Vizu_Flow_Exec(); // визуализация процента исполненных инструкций
//
} // --- конец Finalize_Except_SET ---------------------------------------------

