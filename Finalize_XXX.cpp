
#define TEST_PRINT  /* тестовая печать */ \
/*
t_printf( "\n-=- Выполнившаяся инструкция (i_Set): #%d [%s %s,%s,%s(%f),|%s|]  {%d/%d/%d|%d/%d/%d}\n\
-=- Зависимая инструкция    (i/Rule): #%d/%d [%s %s,%s,%s,|%s|]  {%d/%d/%d/%d|%d/%d}\n",\
i_Set, \
Mem_Instruction[i_Set].Set, Mem_Instruction[i_Set].aOp1, Mem_Instruction[i_Set].aOp2, \
aResult, Result, Mem_Instruction[i_Set].aPredicat, \
  Mem_Instruction[i_Set].fPredicat, Mem_Instruction[i_Set].fPredicat_TRUE,  Mem_Instruction[i_Set].fSpeculateExec, \
  Mem_Instruction[i_Set].fExec, Mem_Instruction[i_Set].fExecOut, Mem_Instruction[i_Set].fAddBuffer, \
i, Rule, \
Mem_Instruction[i].Set, Mem_Instruction[i].aOp1, Mem_Instruction[i].aOp2, Mem_Instruction[i].aResult, \
  Mem_Instruction[i].aPredicat, \
  flagNot,flagPredicat,flagPredicat_TRUE, SpeculateExec, \
  Mem_Instruction[i].fPredicat_TRUE, Mem_Instruction[i].fSpeculateExec );
*/

#define TUNE_FLAGS /* формирование флогов flagNot,flagPredicat,flagPredicat_TRUE */ \
if ( !isPredicat ) /* это инструкция - НЕ ПРЕДИКАТ... */ \
 flagNot = ( aPredicat[0] == symbolNot_1 || aPredicat[0] == symbolNot_2 ) \
             ? true : false; /* TRUE, если в поле aPredicat первый символ '!' или '~' (отрицание) */ \
/* проверяем, совпадает ли имя возврашённой переменной с именем */ \
/* переменной в поле предиката ЗАВИСИМОЙ инструкции */ \
flagPredicat = false; /* начальная установка */ \
if( !isPredicat &&  /* ЗАВиСИМАЯ инструкция - НЕ ПРЕДИКАТ */ \
      strcmp( aPredicat, trueLowerCase  ) && /* "и" это НЕ статический true */ \
      strcmp( aPredicat, falseLowerCase ) )  /* "и" это НЕ статический false */ \
 if( (  flagNot && !strcmp( &aPredicat[1], aResult ) ) || /* флаг-ПРЕДИКАТ отрицается (имя начинается с '!' или '~' ) */ \
     ( !flagNot && !strcmp(  aPredicat,    aResult ) ) ) /* флаг-ПРЕДИКАТ не отрицаетсяСЯ (имя не нечинается с '!' или '~' ) */ \
  flagPredicat = true; \
/* теперь определяем значение Result на true или false и окончательно */ \
/* (с учётом статических true/false) устанавливаем flagPredicat_TRUE */ \
 flagPredicat_TRUE = false; /* начальная установка */ \
 if( flagPredicat ) /* переменная-предикат определена, но значение ещё неизвестно */ \
  if( ( flagNot && !Result ) || /* имя начинается с '!' или '~' и Result==FALSE */ \
     ( !flagNot &&  Result ) ) /* имя Не начинается с '!' или '~' и Result==TRUE */ \
   flagPredicat_TRUE = true; \
/* отдельно обрабатываем статический true или false */ \
 if( !strcmp( aPredicat, trueLowerCase ) ) /* если true... */ \
  flagPredicat_TRUE = true; \
 if( !strcmp( aPredicat, falseLowerCase ) ) /* если false... */ \
  flagPredicat_TRUE = false; \
/*-*/

#define DO_OPS_2 /* вариант 2-х операндов в инструкции */ \
if( Ready_Op1 ) { \
 MI_FOP1(i) = true; \
 snprintf(tmp,sizeof(tmp), " #%d/%d(1|2)", i,Rule); strcat(strInfoLine, tmp); } \
/*-*/ \
if( Ready_Op2 ) { \
 MI_FOP2(i) = true; \
 snprintf(tmp,sizeof(tmp), " #%d/%d(2|2)", i,Rule); strcat(strInfoLine, tmp); } \
/*-*/ \
if( MI_FOP1(i) && MI_FOP2(i) ) { \
 snprintf(tmp,sizeof(tmp), " #%d/%d(*|2)", i,Rule); strcat(strInfoLine, tmp); }
/*-*/
#define DO_OPS_1 /* вариант 1-го операнда в инструкции */ \
if( Ready_Op1 ) { \
 MI_FOP1(i) = true; \
 snprintf(tmp,sizeof(tmp), " #%d/%d(1|1)", i,Rule); strcat(strInfoLine, tmp); \
 snprintf(tmp,sizeof(tmp), " #%d/%d(*|2)", i,Rule); strcat(strInfoLine, tmp); }
/*-*/

#define TURN_ON_FP_TRUE /* включить бит для индикации цветом истинности флага-ПРЕДИКАТА */ \
if( flagPredicat_TRUE ) \
 Mem_Instruction[i].fPredicat_TRUE = true;  // установим бит флаг-ПРЕДИКАТ для индикации цветом
/*-*/

#define TURN_ON_FSPECUL_EXEC_2 /* установить бит режима спекулятивного выполнения (2 операнда)  */ \
if(  MI_FOP1(i) && MI_FOP2(i) && /* по флагам готовности 1-й и 2-й операнды ГОТОВЫ */ \
  ( ( flagPredicat && /* имя флага-предимката совпадает с заданным */ \
     !Mem_Instruction[i].fPredicat_TRUE ) ||  /* значение флага-предикат сброшен */ \
     !strcmp( aPredicat, falseLowerCase ) ) ) /* статический false */ \
 Mem_Instruction[i].fSpeculateExec = true; /* установим флаг для индикации цветом в ячейках таблицы */
//

#define TURN_ON_FSPECUL_EXEC_1 /* установить бит режима спекулятивного выполнения (1 операнд)  */ \
if( MI_FOP1(i) && /* по флагам готовности 1-й операнд ГОТОВ */ \
  ( ( flagPredicat && /* имя флага-предимката совпадает с заданным */ \
   !Mem_Instruction[i].fPredicat_TRUE ) ||  /* значение флага-предикат сброшен */ \
   !strcmp( aPredicat, falseLowerCase ) ) ) /* статический false */ \
 Mem_Instruction[i].fSpeculateExec = true; /* установим флаг для индикации цветом в ячейках таблицы */
//

#define ADD_TO_BUFF_2 /* добавить инструкцию в буфер для стандартного выполнения (2 операнда) */ \
if( MI_FOP1(i) && MI_FOP2(i) ) /* флаги готовности у 1-го и 2-го операндов */ \
 Add_toBuffer( i, Rule ); /* добавить ГКВ-команду в буфер команд для исполнения */
//

#define ADD_TO_BUFF_1 /* добавить инструкцию в буфер для стандартного выполнения (1 операнд) */ \
if( MI_FOP1(i) ) /* флаги готовности у 1-го операндовf */ \
 Add_toBuffer( i, Rule ); /* добавить ГКВ-команду в буфер команд для исполнения */
//

#define ADD_TO_BUFF_SPECUL_2 /* добавить инструкцию в буфер с возможностью спекулятивного выполнения (2 операнда) */ \
if( MI_FOP1(i) && MI_FOP2(i) && /* по флагам готовности 1-й и 2-й операнды ГОТОВЫ */ \
  ( ( !SpeculateExec &&   Mem_Instruction[i].fPredicat_TRUE ) || /* стандартное выполнение */ \
  (    SpeculateExec && ( Mem_Instruction[i].fPredicat_TRUE || /* стандартное выполнения */ \
                          Mem_Instruction[i].fSpeculateExec ) ) ) ) /* спекулятивное выполнение */ \
 Add_toBuffer( i, Rule ); /* добавить ГКВ-инструкцию в буфер команд для исполнения */
//

#define ADD_TO_BUFF_SPECUL_1 /* добавить инструкцию в буфер с возможностью спекулятивного выполнения (1 операнд) */ \
if( MI_FOP1(i) && /* по флагам готовности 1-й операнд ГОТОВ */ \
  ( ( !SpeculateExec &&   Mem_Instruction[i].fPredicat_TRUE ) || /* стандартное выполнение */ \
  (    SpeculateExec && ( Mem_Instruction[i].fPredicat_TRUE || /* стандартное выполнения */ \
                          Mem_Instruction[i].fSpeculateExec ) ) ) ) /* спекулятивное выполнение */ \
 Add_toBuffer( i, Rule ); /* добавить ГКВ-инструкцию в буфер команд для исполнения */
//


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall
Finalize_Only_SET( INT i_Set )
{ // выполнение инструкции SET номер i_Set !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// предполагается, что это мгновенно (время учитывать не надо)..................
// инструкция SET выполняется НЕ ПРОЦЕССОРОМ, а ВХОДНЫМ коммуникатором !!!
 char Set[_SET_LEN]="\0",
      aResult[_ID_LEN]="\0",
      aPredicat[_ID_LEN]="\0", // поле предиката
      namePredicat[_ID_LEN] = "\0", // имя поля предиката (без возможного флага отрицания)
      strInfoLine[_4096]="\0",
      tmp[_512]="\0";
 bool s_isPredicat, // TRUE, если РОДИТЕЛЬСКАЯ (выполнившаяся) инструкция есть ПРЕДИКАТ
      isPredicat, // TRUE, если ЗАВИСИМАЯ инструкция ПРЕДИКАТ
      flagNot, // TRUE, если в ЗАВИСИМОМ операторе первый символ имени флага предиката "!" или "~"
      flagPredicat, // TRUE, если в имени ЗАВИСИМОЙ инструкция есть переменная (XXX или !XXX или ~XXX, где XXX == aResult)
      flagPredicat_TRUE, // TRUE, если в ЗАВИСИМОЙ инструкция флаг предиката TRUE (с учётом isNot)
      Ready_Op1,Ready_Op2 ; // совпадение имён операндов в ЗАВИСИМОЙ инструкция с именем результата в ВЫПОЛНИВШЕМСЯ
 short int Rule; //управляющая переменная в переключателу switch()
 REAL valPredicat; // значение поля-предиката определённой инструкции
//
 if( !Regim ) // не выполнять - закончить счет ---------------------------------
  return;
//
 REAL Result = StrToReal( Mem_Instruction[i_Set].aOp1, i_Set ); // запомнили значение 1-го операнда (константа) инструкции SET номер i_Set
 strcpy( aResult, Mem_Instruction[i_Set].aResult ); // строка-адрес результата выполненной инструкции
//
 s_isPredicat = false; // is_Predicat( Mem_Instruction[i_Set].Set ); // у SET всегда FALSE
//
////////////////////////////////////////////////////////////////////////////////
 Add_toData( i_Set, aResult, Result ); // добавим в Mem_Data[] и для визуализации
////////////////////////////////////////////////////////////////////////////////
//
// установим флаг единократного выполнения SET .................................
//
 Mem_Instruction[i_Set].fExecOut = true; // установили флаг единичного выполнения
 mS->Cells[6][i_Set+1] = Vizu_Flags(i_Set); // визуализировали это в таблице SG_Sets
//
 t_printf( "-I- %s(){1}: инструкция #%d [%s] выполнена (%s) -I-",
            __FUNC__, i_Set, Line_Set(i_Set, 1, 0.0), Get_Time_asLine());
//
////////////////////////////////////////////////////////////////////////////////
// установим флаг ГОТОВ у ВСЕХ операндов, совпадающих по имени с адресом aResult в пуле инструкций Mem_Sets[i_set]
//
 strcpy(strInfoLine, "\0"); // очистим strInfoLine
//
////////////////////////////////////////////////////////////////////////////////
 for( INT i=0; i<Really_Set; i++ ) // по всему пулу инструкций в Mem_Instruction[]
 {
  strcpy( Set, Mem_Instruction[i].Set ); // ... так удобнее для дальнейшей работы !
  if( is_SET( Set ) ) // это инструкция SET - не обрабатываем ! ---------------
   continue;
//
  strcpy( aPredicat, Mem_Instruction[i].aPredicat ); // будем работать с aPredicat, не изменяя Mem_Instruction[i].aPredicat
//
  isPredicat = is_Predicat( Set ); // TRUE, если ЗАВИСИМАЯ инструкция - ПРЕДИКАТ
//
  TUNE_FLAGS // формирование флогов flagNot,flagPredicat,flagPredicat_TRUE
//
  Ready_Op1 = MI_AOP1( i ) ; // флаг готовности операнда 2
  Ready_Op2 = MI_AOP2( i ) ; // флаг готовности операнда 2
//
////////////////////////////////////////////////////////////////////////////////
  switch( Rule=10*Get_CountOperandsByInstruction(Set)+isPredicat )
  {
////////////////////////////////////////////////////////////////////////////////
   case 10: // один операнд; const -> НЕ_ПРЕДИКАТ + (возможно) flag-ПРЕДИКАТ
//
   DO_OPS_1 // обработка 1-го операнда (из 1-го в инструкции)
//
   TURN_ON_FP_TRUE // включить бит для индикации цветом истинности флага-ПРЕДИКАТА
//
   TURN_ON_FSPECUL_EXEC_1 // установить бит режима спекулятивного выполнения (1 операнд)
//
   TEST_PRINT // отладочная печать
//
   ADD_TO_BUFF_SPECUL_1 /* добавить инструкцию в буфер с возможностью спекулятивного выполнения (1 операнд) */ \
//
   break; // конец Rule==10
//
////////////////////////////////////////////////////////////////////////////////
   case 11:  // два операнда; const -> ПРЕДИКАТ
//
   DO_OPS_1 // обработка 1-го операнда (из 1-го в инструкции)
//
   TEST_PRINT // отладочная печать
//
   ADD_TO_BUFF_1 /* добавить инструкцию в буфер для стандартного выполнения (1 операнд) */
//
   break; // конец Rule==11
//
////////////////////////////////////////////////////////////////////////////////
   case 20: // два операнда; const -> НЕ_ПРЕДИКАТ + (возможно) flag-ПРЕДИКАТ
//
   DO_OPS_2 // обработка 2-х операндов (из 2-х в инструкции)
//
   TURN_ON_FP_TRUE // включить бит для индикации цветом истинности флага-ПРЕДИКАТА
//
   TURN_ON_FSPECUL_EXEC_2 // установить бит режима спекулятивного выполнения (2 операнда)
//
   TEST_PRINT // отладочная печать
//
   ADD_TO_BUFF_SPECUL_2 // добавить инструкцию в буфер с возможностью спекулятивного выполнения (2 операнда)
//
   break; // конец Rule==20
//
////////////////////////////////////////////////////////////////////////////////
   case 21: // два операнда; const -> ПРЕДИКАТ
//
   DO_OPS_2 // обработка 2-х операндов (из 2-х в инструкции)
//
   TEST_PRINT // отладочная печать
//
   ADD_TO_BUFF_2 // добавить инструкцию в буфер для стандартного выполнения (2 операнда)
//
   break; // конец Rule==21
//
////////////////////////////////////////////////////////////////////////////////
   default:
//
    t_printf( "\n-E- Некорректное значение i/Rule=%d/%d -E-\n", i,Rule );
//
   break; // других Rule не бывает ---------------------------------------------
////////////////////////////////////////////////////////////////////////////////
//
  } // конец switch по Rule для i-той инструкции -------------------------------
//
////////////////////////////////////////////////////////////////////////////////
//
   mS->Cells[6][i+1] = Vizu_Flags(i); // визуализировали ФЛАГИ данной инструкции
//
  } // конец for( INT i=0; i<Really_Set; i++ ) ---------------------------------
//  
////////////////////////////////////////////////////////////////////////////////
//
  Draw_AllTableInstructions(); // выделение ячеек цветом (будет вызываться при выполнении каждого SET'a )
//
  if( strlen(strInfoLine) ) // если в strInfoLine что-то заносилось...
   t_printf( "-I- %s(){2}: по выполнению инструкции #%d установлены флаги готовности операндов у инструкций: %s -I-",
              __FUNC__, i_Set, strInfoLine);
//
 Already_Exec ++ ; // число уже исполненных инструкций
//
 AttemptExecMaxInstructions_fromBuffer(); // пытаемся выполнить как можно больше ГКВ-инструкций из буфера
// для фактического выполнения инструкций из AttemptExecMaxInstructions_fromBuffer()
// вызывается ExecuteInstructions_Except_SET( i_Set )
//
 Vizu_Flow_Exec(); // визуализация процента исполненных инструкций
//
} // ----- конец Finalize_Only_SET ---------------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall // вызывается для завершения выполнения инструкции на АИУ i_Proc
Finalize_Except_SET( INT i_Proc ) // все операци кроме SET !!!!!!!!!!!!!!!!!!!!!
{ // устанавливаются флаги готовности у входных операндов иных инструкций, зависящих
// по входным операндам от результата выполнения данной на АИУ номер i_Proc
 char Set[_SET_LEN]="\0",
      aResult[_ID_LEN]="\0",
      aPredicat[_ID_LEN]="\0", // поле предиката
      namePredicat[_ID_LEN] = "\0", // имя поля предиката (без возможного флага отрицания)
      strInfoLine[_4096]="\0",
      tmp[_512]="\0";
 bool s_isPredicat, // TRUE, если РОДИТЕЛЬСКАЯ (выполнившаяся) инструкция есть ПРЕДИКАТ
      isPredicat, // TRUE, если ЗАВИСИМАЯ инструкция есть ПРЕДИКАТ
      flagNot, // TRUE, если в ЗАВИСИМОЙ инструкции первый символ имени флага-предиката "!" или "~"
      flagPredicat, // TRUE, если в имени ЗАВИСИМОЙ инструкции есть переменная (XXX или !XXX или ~XXX, где XXX == aResult)
      flagPredicat_TRUE, // TRUE, если в ЗАВИСИМОЙ инструкции флаг-предикат TRUE (с учётом isNot)
      Ready_Op1,Ready_Op2 ; // совпадение имён операндов в ЗАВИСИМОЙ инструкции с именем результата в ВЫПОЛНИВШЕМСЯ
 short int Rule; //управляющая переменная в переключателу switch()
 REAL  valPredicat; // значение поля-предиката определённой инструкции
//
 if( !Regim ) // не выполнять - закончить счет ---------------------------------
  return;
//
 INT i_Set = Mem_Proc[i_Proc].i_Set; // на этом АИУ выполнялась инструкция номер i_Set
//
 REAL Result = Mem_Proc[i_Proc].Result; // значение результата выполненной операции
//
 strcpy( aResult, Mem_Proc[i_Proc].aResult ); // запомнили адрес результата выполнения инструкции i_Set_Result
//
////////////////////////////////////////////////////////////////////////////////
// // при СПЕКУЛЯТИВНОМ выполнении добавлять информацмю в пул данных не нужно !
 if( !( SpeculateExec && Mem_Instruction[i_Set].fSpeculateExec ) )
 {
  Add_toData( i_Set, Mem_Proc[i_Proc].aResult, Result ); // добавить результат выполнившейся инструкции
//
  t_printf( "-I- %s(){1}: АИУ #%d выполнило инструкцию #%d [%s] [%d/%d/%d тактов] -I-",
            __FUNC__, i_Proc, i_Set, Line_Set(i_Set, 1, 0.0),
            Mem_Proc[i_Proc].tick_Start, localTick, localTick-Mem_Proc[i_Proc].tick_Start);
 }
//
////////////////////////////////////////////////////////////////////////////////
//
 s_isPredicat = is_Predicat( Mem_Instruction[i_Set].Set ); // TRUE, если выполнившаяся инструкция суть ПРЕДИКАТ
//
 Vizu_Data(); // визуализировать...
//
////////////////////////////////////////////////////////////////////////////////
// добавить запись в набор строк Tpr для анализа загрУженности АИУ..............
//
 snprintf( strInfoLine,sizeof(strInfoLine), "%10d%10d%10d%10d%10d [%s]",
           i_Proc, Mem_Proc[i_Proc].tick_Start, localTick, localTick-Mem_Proc[i_Proc].tick_Start, i_Set,
           Line_Set(i_Set, -1, Result ) ) ;
//
 if( SpeculateExec && Mem_Instruction[i_Set].fSpeculateExec ) // спекулятивное выполнение
  strcat( strInfoLine, SPECUL );
//
 mTpr->Add( strInfoLine ); // добавили строку в список Tpr
// t_printf( "\n=-=-=-=%s\n", strInfoLine );
//
 strcpy(strInfoLine, "\0"); // очистим strInfoLine для дальнейшего использования
//
 if( SpeculateExec && Mem_Instruction[i_Set].fSpeculateExec ) // СПЕКУЛЯТИВНОЕ выполнение !
  goto cont;
//
//==============================================================================
 for( INT i=0; i<Really_Set; i++ ) // по всем инструкциям из Mem_Instruction[]...
 {
//
  if( i == i_Set ) // кроме только что выполненногй инструкция..................
   continue;
//
  strcpy( Set, Mem_Instruction[i].Set ); // ... так удобнее для дальнейшей работы !
  if( is_SET(Set) ) // инструкция SET уже давно едИножды выполнена !
   continue;
//
  strcpy( aPredicat, Mem_Instruction[i].aPredicat ); // будем работать с aPredicat, не изменяя Mem_Instruction[i].aPredicat
//
  isPredicat = is_Predicat( Set ); // TRUE, если это инструкция ПРЕДИКАТ
//
  TUNE_FLAGS // формирование флогов flagNot,flagPredicat,flagPredicat_TRUE
//
  if(Mem_Instruction[i].fExec    || // если инструкция ВЫПОЛНЯЕТСЯ "или"
     Mem_Instruction[i].fExecOut || // уже ВЫПОЛНЕНА "или"
     Mem_Instruction[i].fAddBuffer) // уже ДОБАВЛЕНА В БУФЕР
   continue;
//
  Ready_Op1 = MI_AOP1( i ) ; // флаг готовности операнда 1
  Ready_Op2 = MI_AOP2( i ) ; // флаг готовности операнда 2
//
////////////////////////////////////////////////////////////////////////////////
//
  switch( Rule = 100*Get_CountOperandsByInstruction(Set) + 10*s_isPredicat + isPredicat )
  {
////////////////////////////////////////////////////////////////////////////////
   case 100: // один операнд; НЕ_ПРЕДИКАТ -> НЕ_ПРЕДИКАТ + (возможно) flag-пПРЕДИКАТ
//
   DO_OPS_1 // обработка 1-го операнда (из 1-го в инструкции)
//
// TURN_ON_FP_TRUE( i ) - необходимо только для ПРЕДИКАТ->НЕ_ПРЕДИКАТ (Rule==110 && Rule==210)
//
   TURN_ON_FSPECUL_EXEC_1 // установить бит режима спекулятивного выполнения (1 операнд)
//
   TEST_PRINT // отладочная печать
//
   ADD_TO_BUFF_SPECUL_1 /* добавить инструкцию в буфер с возможностью спекулятивного выполнения (1 операнд) */ \
//
   break; // конец Rule==100
//
////////////////////////////////////////////////////////////////////////////////
   case 101: // один операнд; НЕ_ПРЕДИКАИ -> ПРЕДИКАТ
//
   DO_OPS_1 // обработка 1-го операнда (из 1-го в инструкции)
//
   TEST_PRINT // отладочная печать
//
   ADD_TO_BUFF_1 // добавить инструкцию в буфер для стандартного выполнения (1 операнд)
//
   break; // конец Rule==101
//
////////////////////////////////////////////////////////////////////////////////
   case 110: // один операнд; ПРЕДИКАT -> НЕ_ПРЕДИКАТ + (возможно) flag-ПРЕДИКАТ
//
   DO_OPS_1 // обработка 1-го операнда (из 1-го в инструкции)
//
   TURN_ON_FP_TRUE // включить бит для индикации цветом истинности флага-ПРЕДИКАТА
//
   TURN_ON_FSPECUL_EXEC_1 // установить бит режима спекулятивного выполнения (1 операнд)
//
   TEST_PRINT // отладочная печать
//
   ADD_TO_BUFF_SPECUL_1 // добавить инструкцию в буфер с возможностью спекулятивного выполнения (1 операнд)
//
   break; // конец Rule==110
//
////////////////////////////////////////////////////////////////////////////////
   case 111: // один операнд; ПРЕДИКАТ -> ПРЕДИКАТ
//
   DO_OPS_1 // обработка 1-го операнда (из 1-го в инструкции)
//
   TEST_PRINT // отладочная печать
//
   ADD_TO_BUFF_1 /* добавить инструкцию в буфер для стандартного выполнения (1 операнд) */ \
//
   break; // конец Rule==111
//
////////////////////////////////////////////////////////////////////////////////
   case 200: // два операнда; НЕ_ПРЕДИКАТ -> НЕ_ПРЕДИКАТ + (возможно) flag-ПРЕДИКАТ
//
   DO_OPS_2 // обработка 2-х операндов (из 2-х в инструкции)
//
// TURN_ON_FP_TRUE( i ) - необходимо только для ПРЕДИКАТ->НЕ_ПРЕДИКАТ (Rule==110 && Rule==210)
//
   TURN_ON_FSPECUL_EXEC_2 // установить бит режима спекулятивного выполнения (2 операнда)
//
   TEST_PRINT // отладочная печать
//
   ADD_TO_BUFF_SPECUL_2 // добавить инструкцию в буфер с возможностью спекулятивного выполнения (2 операнда)
//
   break; // конец Rule==200
//
////////////////////////////////////////////////////////////////////////////////
   case 201: // два операнда; НЕ_ПРЕДИКАТ -> ПРЕДИКАТ
//
   DO_OPS_2 // обработка 2-х операндов (из 2-х в инструкции)
//
   TEST_PRINT // отладочная печать
//
   ADD_TO_BUFF_2 // добавить инструкцию в буфер для стандартного выполнения (2 операнда)
//
   break; // конец Rule==201
//
////////////////////////////////////////////////////////////////////////////////
   case 210: // два операнда; ПРЕДИКАТ -> НЕ_ПРЕДИКАТ + возможно, флаг-ПРЕДИКАТ
//
   DO_OPS_2 // обработка 2-х операндов (из 2-х в инструкции)
//
   TURN_ON_FP_TRUE // включить бит для индикации цветом истинности флага-ПРЕДИКАТА
//
   TURN_ON_FSPECUL_EXEC_2 // установить бит режима спекулятивного выполнения (2 операнда)
//
   TEST_PRINT // отладочная печать
//
   ADD_TO_BUFF_SPECUL_2 // добавить инструкцию в буфер с возможностью спекулятивного выполнения (2 операнда)
//
   break; // конец Rule==210
//
////////////////////////////////////////////////////////////////////////////////
   case 211: // два операнда; ПРЕДИКАТ -> ПРЕДИКАТ
//
   DO_OPS_2 // обработка 2-х операндов
//
   TEST_PRINT // отладочная печать
//
   ADD_TO_BUFF_2 // добавить инструкцию в буфер для стандартного выполнения (2 операнда)
//
   break; // конец Rule==211
//
////////////////////////////////////////////////////////////////////////////////
   default: // других Rule не бывает -------------------------------------------
//
    t_printf( "\n-E- Некорректное значение i/Rule=%d/%d -E-\n", i,Rule );
//
   break;
//
////////////////////////////////////////////////////////////////////////////////
//
  } // конец switch по Rule для i-той инструкция -------------------------------
//
////////////////////////////////////////////////////////////////////////////////
//
   mS->Cells[6][i+1] = Vizu_Flags(i); // визуализировали ФЛАГИ инструкций
//
  } // конец for( INT i=0; i<Really_Set; i++ ) ---------------------------------
//
////////////////////////////////////////////////////////////////////////////////
//
 if( strlen(strInfoLine) ) // если в strInfoLine что-то записывалось...
  t_printf( "-I- %s(){2}: по выполнению инструкции #%d/%d установлены флаги готовности операндов у инструкций: %s -I-",
             __FUNC__, i_Set, i_Proc, strInfoLine );
//
////////////////////////////////////////////////////////////////////////////////
cont: // конец спекулятивного выполнения инструкций ============================
////////////////////////////////////////////////////////////////////////////////
//
// устанавливаем флаг однократного выполнения инструкции .......................
 Mem_Instruction[i_Set].fExecOut = true; // установили флаг ИНСТРУКЦИЯ_ИСПОЛЬЗОВАНА
// снимаем флаг ИНСТРУКЦИЯ_ВЫПОЛНЯЕТСЯ
 Mem_Instruction[i_Set].fExec    = false; // сняли флаг ИНСТРУКЦИЯ_ВЫПОЛНЯЕТСЯ
//
 Draw_AllTableInstructions(); // выделение ячеек цветом (после *.fExecOut ...)
//
////////////////////////////////////////////////////////////////////////////////
//
 Mem_Proc[i_Proc].Busy = false; // АИУ номер i_Proc теперь СВОБОДНО !!! --------
//
 t_printf( "-I- %s(){3}: АИУ #%d освобождено (%s) после выполнения инструкции #%d -I-",
            __FUNC__, i_Proc, Get_Time_asLine(), i_Set);
//
 Free_Proc ++ ; // число свободных АИУ увеличили на 1 ==========================
//
////////////////////////////////////////////////////////////////////////////////
 sleep_for_vizu_buffer // ждем-с для визуализации буфера
////////////////////////////////////////////////////////////////////////////////
 AttemptExecMaxInstructions_fromBuffer(); // пытаемся выполнить как можно больше ГКВ-инструкций из буфера
// для фактического выполнения инструкций из AttemptExecMaxInstructions_fromBuffer()
// вызывается ExecuteInstructions_Except_SET( i_Set )
////////////////////////////////////////////////////////////////////////////////
 sleep_for_vizu_buffer // визуализируем буфер...
////////////////////////////////////////////////////////////////////////////////
//
 Already_Exec ++ ; // число уже испОлненных инструкций
//
 Vizu_Flow_Exec(); // визуализация процента исполненных инструкций
//
} // --- конец Finalize_Except_SET ---------------------------------------------







