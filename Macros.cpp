//
void   __fastcall Expansion_SET( char *s ); // расширение макроса препроцессором (инструкция SET)
void   __fastcall Expansion_1_2_Opd( char *s, int nOpd ); // обработка инструкции с 1-2 операндами
void   __fastcall Select_Instruction_for_Macros_Expansion(); // выбор типа инструкции для расширения препроцессором
double __fastcall pcExpression( char* Expression, double Value_1, double Value_2 ); // вычислить и вернуть double
int    __fastcall testIndex(char* str, char chr ); // возвращает число не 'chr' символов
void   __fastcall handRes_asValue( char *Result, INT i ); // обработка поля-результата в виде переменной (не псевдомассива)
void   __fastcall handRes_asMassiv( char *Result, INT i ); // обработка поля-результата в форме псевдомассива
void   __fastcall handOpd_asValue( char* Opd, INT i ); // // обработка поля-операнда в виде переменной (не псевдомассива)
void   __fastcall handOpd_asMassiv( char* Opd, INT i ); // // обработка поля-операнда в виде псевдомассива
void   __fastcall replace_Str( char s[], const char sOld[], const char sNew[] ); // замена cI на sNew в строке s
void   __fastcall make1D_psMass( char str[], INT i ); // находит и обрабатывает (расширяет) макросы в 1D-псевдомассивы
void   __fastcall tf_printf( char* str, FILE* fptr ); // вывод строки str во фрейм протокола и файл fptr
//
#define _tf_printf(str) t_printf("%s",str);fprintf(fptrOut,"%s\n",str); // макрос вывода строки str во фрейм протокола и файл fptr
// ограничения на имена переменных: "длина>0" и "первый символ - буква" или "первый=attrvar"
#define permissName(str) ( strlen(str)&&(isalpha(str[0])||str[0]==attrVar[0]) ) 
//
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall tf_printf( char* str, FILE* fptr )
{ // вывод строки str  во фрейм протокола + в файл fptr
 t_printf( "%s", str );
 fprintf( fptr, "%s\n", str );
} // ----- конец tf_printf -----------------------------------------------------

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
bool __fastcall Process_Macros()
{ // читаем инструкции из файла FileNameSet, ищем заголвки макросов, запоминаем
// тела макросов в mBody (тип TStringList), вызываем обработчик макросов и создаём
// новый файл с полным текстом (расщирения макросов)
 char str[_1024]="\0", strSave[_1024]="\0"; // строка для считывания и расшифровки инструкций + сохранение исходной строки
//
 flagMacroTitle = false ; // !!!!!! вначале (global) !!!!!
//
 if( !(fptrIn = fopen( FileNameSet, "r") ) ) // файл fptrIn (global) открыть не удалось...
  return false;
//
 strcpy( FileNameSetPrP, ChangeFileExt(FileNameSet,ExtPrP).c_str() ); // имя файла инструкций после препроцессора
 if( !(fptrOut = fopen( FileNameSetPrP, "w") ) ) // файл инструкций после препроцессора fptrOut (global) открыть не удалось...
  return false;
//
////////////////////////////////////////////////////////////////////////////////
//
 for( INT i=0; i<max_Instruction; i++ ) // по строкам инструкций
  {
//
   if(fgets(str, sizeof(str), fptrIn) == NULL) // читаем строку из fptr
    break; // если строки кончились, функция fgets возвращает NULL
//
   strcpy( strSave, str ); // сохраним исходную строку
//
   if(str[strlen(str)-1] == 10) // если в конце символ новой строки (10) в десятичной)...
    str[strlen(str)-1] = ' ';   // ... то заменим на пробел !
//
// ----- все Tab в строке str заменяем на пробелы ------------------------------
   for( INT i=0; i<strlen(str); i++ ) // по всем символам строки...
    if( str[i] == VK_TAB ) // если i-тый символ есть Tab (9/0x9)...
     str[i] = VK_SPACE; // то заменяем его на пробел (32/0x20) !
//
   DSTA( str ); // чистка строки str от лидирующих и терминирующих Tabs и  пробелов
//
   if( !strlen(str) || // если длина строки нулевая...
       str[0]==startComments[0] || // или строка начинается с ";"...
       str[0]==':' ) // частая описка...
    goto cont;
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
  i_env_BypassMacro = setjmp( env_BypassMacro ); // установили точку перехода
  if( i_env_BypassMacro ) // не ноль - значит, сюда был прыжок !!!!!!!!!!!!!!!!!
   goto label_BypassMacro;
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
   make1D_psMass( str, i ); // ищем заголовки макросов 1D-псевдо-массивов -------
//  make2D_psMass( str, i ); // ищем заголовки макросов 2D-псевдо-массивов -------
//   goto cont; // сохранить строку в файле fptrOut
   continue; // к следующей записи файла инструкций
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////
label_BypassMacro: // сюда переходим по longjmp --------------------------------
////////////////////////////////////////////////////////////////////////////////
//
cont: // для прОпуска строки с возможностью копирования в файл FileNameSetPrP
// ----- добавляем строки в выходной файл FileNameSetPrP -----------------------

// t_printf(  "4---%s-", strSave );

 fputs( strSave, fptrOut ); // сохраняем строку исходного файла
//
 } // конец цикла i по строкам в файле FileNameSets
////////////////////////////////////////////////////////////////////////////////
//
 fclose( fptrIn  ); // закрываем все открытые файлы
 fclose( fptrOut );
//
 return 0; // всё Ok
//
} // --------- конец Process_Macros --------------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall make1D_psMass( char str[], INT i )
{ // находит и обрабатывает (расширяет) макрос в 1D-псевдомассивы --------------
//
//  t_printf( "1---%d -%s-", i,str  );

  if( !strncmp( str, "for[", 4 ) && // если в начале str находится"for[" (первые 4 символа) 'и'
       sscanf( str, "for[%c]=%d,%d,%d{", &cI,&minI,&maxI,&dI ) == 4 ) // все 4 поля корректно прочитаны..!
  {
   if( !dI || // неверен диапазон изменения переменных цикла (приводит к  беконечному повтору )
     (  maxI>=minI && dI<=0) || ( maxI<=minI && dI>=0) )
   {
    t_printf( "\n-M- Некорректен диапазон изменения [%d,%d,%d] переменной цикла '%c' -M-\n", minI,maxI,dI,cI );
    return;
   }
//
   numbFor ++ ; // номер for в данной программе
   flagMacroTitle = true; // нашли строку с заголовком 1D-макроса
   startN = i; // запомнили номер строки с заголоаком 1D-макроса
   mBody->Clear(); // очистили mBody типа TStringList
   mBody->Add( str ); // запомнили заголовок 1D-макроса
   mExpand->Clear(); // готовимся к заполнению строка расширения макроса !!!
   return; // переходим к следующей строке str файла инструкций
  } // конец "нашли заголовок 1D-макроса
//
  if( flagMacroTitle && str[0] == '}' ) // после заголовка макроса в строке встретился "}"
  {
   flagMacroTitle = false; // в строке встретился "}"
   mBody->Add( str ); // добавляем в mBody строку "}"
   endN = i; // запомним номер строки с последним символом макроса
//
////////////////////////////////////////////////////////////////////////////////
   Select_Instruction_for_Macros_Expansion(); // выбор типа инструкции для расширения препроцессором
////////////////////////////////////////////////////////////////////////////////
   tf_printf( Format("; \n; начало расширения макроса: заголовок 'for[%s]=%d,%d,%d {'\n;", // cI -> %s !!!
              OPENARRAY(TVarRec,(cI,int(minI),int(maxI),int(dI)))).c_str(), fptrOut );
   for( int j=0; j<mBody->Count; j++ )
    tf_printf( Format("; %s", OPENARRAY(TVarRec, (mBody->Strings[j].c_str()) )).c_str(), fptrOut );
   for( int j=0; j<mExpand->Count; j++ ) // добавление расширения на псевдо-массивы
    tf_printf( Format("%s",  OPENARRAY(TVarRec, (mExpand->Strings[j].c_str()) )).c_str(), fptrOut );
   tf_printf( Format("; \n; конец расширения макроса: заголовок 'for[%s]=%d,%d,%d {'\n;", // cI -> %s !!!
              OPENARRAY(TVarRec,(cI,int(minI),int(maxI),int(dI)))).c_str(), fptrOut );
////////////////////////////////////////////////////////////////////////////////
   return; // переходим к следующей строке str файла инструкций
  }
//
  if( flagMacroTitle ) // пока не было "}" в строке имеем flagMacroTitle=true
  {
   mBody->Add( str ); // добавляем в mBody строки макроса
   return; // переход к следующей строке str файла инструкций
  }
//
} // ------ конец make1D_psMass ------------------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall replace_Str( char* s, const char* sOld, const char* sNew )
{ // все вхождения sOld (кроме как в именах стандартных функций stdFunc) в s заменяются на sNew
//
 string strTmp; // локальный string (при использовани глобального "портится" sOld)
//
// ------ замена stdFunc[] -----------------------------------------------------
 for( int i=0; i<sizeof(stdFunc)/sizeof(stdFunc[0]); i++ ) // по названиям стандартных функций парсера
 {
  strReplace( w, sizeof(w)-1, s, stdFunc[i], Format( replaceFmt,OPENARRAY(TVarRec,(i))).c_str() );
  strcpy( s, w );
 } // конец for( int i=0; i<sizeof(stdFunc)/sizeof(stdFunc[0]); i++ )
//
 for( int ii=10; ii>=2; ii-- ) // проверка на наличие ii последовательных cI
  if( strstr( s, strTmp.assign(ii,cI).c_str() ) ) 
  {
   t_printf( "\n-M- В строке [%s] для вычислений встречен многократный (%d) повтор индекса '%c' -M-\n", s,ii,cI );
   longjmp( env_BypassMacro, 1 ); // нелокальный переход к точке setjmp !!!!!!!
  }
//
 strReplace( w, sizeof(w)-1, s, sOld, sNew ); // замена строки sOld на строку sNew (обычно cI на X[0])
//
 strcpy( s, w ); // готовимся к восстанвлению строки ---------------------------
//
// ------ восстановление stdFunc[] ---------------------------------------------
 for( int i=0; i<sizeof(stdFunc)/sizeof(stdFunc[0]); i++ ) // по названиям стандартных функций парсера
 {
   strReplace( w, sizeof(w)-1, s, Format( replaceFmt,OPENARRAY(TVarRec,(i))).c_str(), stdFunc[i] );
   strcpy( s, w );
 } // конец for( int i=0; i<sizeof(stdFunc)/sizeof(stdFunc[0]); i++ )
//
} // ------ конец replace_Str --------------------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
double __fastcall pcExpression( char* Expression, double Value_1, double Value_2 )
{ // парсеринг и вычисление выражения Expression от двух переменных Value_1/Value_2
//
 try
 {
  parser.Compile( Expression ); // разборка выражения
  parser.Evaluate( Value_1, Value_2 ); // точка вычисления по переменным X[0],X[1] etc
  return parser.GetResult(); // возвращаем double !!!
 }
 catch(TError error)
 {
  if( flagAlarmParser ) // выдать предупреждение (global)
  {
   MessageBeep( MB_OK ); // звуковое предупреждение...
   snprintf( str,sizeof(str), "ПРЕПРОЦЕССОР: проблема разборки выражения\n\n[%s]" // str - global
                              "\n\nОШИБКА: [%s] в позиции %d",
             Expression, error.error, error.pos );
   MessageBox(0, str, " Ошибка !", MB_OK);
//
   flagAlarmParser = false; // global..!
  } // и больше не выдавать..!
//
 } // конец catch( )
//
} // -------- конец pcExpression -----------------------------------------------

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
int __fastcall testIndex(char* str, char chr )
{ // если в строке str кроме БУКВЫ 'chr' встречаются и иные БУКВЫ, выдаётся число встреч
//
 int count = 0;
//
 for( int i=0; i<strlen(str); i++ ) // по всей строке str
  if( isalpha(str[i]) && str[i] !=chr ) // если БУКВА и НЕ 'chr'
   count++;
//
 return count;
//
} // ------ конец testIndex ----------------------------------------------------

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall Select_Instruction_for_Macros_Expansion()
{ // выбор типа инструкции макроса для расширения препроцессором
//
 char Set[4]; // имя мнемоники инструкции
//
 for( int j=1; j<mBody->Count-1; j++ ) // цикл по строкам содержания макроса (кроме заголовка и последней)
 {
  strncpy( Set, mBody->Strings[j].c_str(), 3 ); // запомнили мнемонику инструкции (3 первых символа)
  strupr( Set ); // переводим в заглавные для корректности сравнения
//
  if( !strcmp( Set, "SET") ) // это SET ..!
   Expansion_SET( mBody->Strings[j].c_str() ); // расширяет макрос по инструкции SET
  else // это не SET (1-2 операнда в инструкции)
   Expansion_1_2_Opd( mBody->Strings[j].c_str(), Get_CountOperandsByInstruction( Set ) );
 }
//
} // --------- конец Select_Instruction_for_Macros_Expansion -------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall handRes_asValue( char *Res, INT i )
{ // обрабатываеи поле результата, если он в форме простой переменной ----------
  if( Get_CountOperandsByInstruction( SetName ) == 1 ) // 1 операнд в инструкции
   sprintf( w, "%s %s, %s%c%d%c%d ;%s", SetName,Opd_1,Res, SymbDelim,numbFor,SymbDelim,i, Comm );
  else // 2 операнда в инструкции
   sprintf( w, "%s %s, %s, %s%c%d%c%d ;%s", SetName,Opd_1,Opd_2,Res, SymbDelim,numbFor,SymbDelim,i, Comm );
//
} // ----- конец handRes_asValue -----------------------------------------------

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall Expansion_SET( char *s )
{ // расширяет макрос по инструкции SET , добавляет расширение в mExpand (TStringList)
//
 int out;
 string strTmp;
//
 for( INT i=minI; i<=maxI; i+=dI ) // по всему заданному диапазону расширения макроса
 {
////////////////////////////////////////////////////////////////////////////////
// ----- разбираем 1-й операнд SET'а -------------------------------------------
//
  Comm[0] = '\0'; // обнуление...
//
  strcpy( str, s ); // копируем, ибо при обработке strtok исходная строка s разрушается
  strcpy( SetName,      p = strtok( str,  " " ) ); // мнемоника
  strcpy( Opd_1,   DAS( p = strtok( NULL, "," ) ) ); // 1-й операнд
  strcpy( Res,     DAS( p = strtok( NULL, ";" ) ) ); // результат
//
  if( strchr(s,';') ) // если в строке есть ';'
   strcpy( Comm, &s[strchr(s,';')-s+1] ); // копируем в Comm всё, правее ';'
//  strcpy( Comm,    DAS( p = strtok( NULL, ""  ) ) ); // комментарий
//
  replace_Str( Opd_1, strTmp.assign(1,cI).c_str(),  "X[0]" ); // замена cI на X[0] исключая имена стандартных функций
//
  sprintf( Opd_1, "%.*g", sizeof(Mem_Data[0].Addr)-1, pcExpression( w,(double)i,0.0 ) );
// ------ обрабатываем поле Res (результат выполнения инструкции) --------------
////////////////////////////////////////////////////////////////////////////////
  if( !strchr(Res, '[') && !strchr(Res,']') ) // в Res нет и '[' и ']' ---------
   handRes_asValue( Res, i ); // обрабатываем результат, если он простая переменная
  else
   handRes_asMassiv( Res, i ); // обрабатываем результат, если он псевдомассив
////////////////////////////////////////////////////////////////////////////////
 } // конец по i (по числу строк расширения) ===================================
//
////////////////////////////////////////////////////////////////////////////////
// for( int i=0; i<mExpand->Count; i++ ) // тестовый вывод
//  t_printf( "#%d# %s", i+1, mExpand->Strings[i] );
////////////////////////////////////////////////////////////////////////////////
//
} // ---------- конец Expansion_SET --------------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall handRes_asMassiv( char *Res, INT i )
{ // обрабатываеи поле результата, если он в форме псевдомассива ---------------
//
  string strTmp;
//
  strcpy( nameMass,  p = strtok( Res,  "[" ) ); // строка до '['
  strcpy( indexMass, p = strtok( NULL, "]" ) ); // строка от '[' до ']'
////////////////////////////////////////////////////////////////////////////////
//
  if( !permissName(nameMass) )
  { // проверка на допустИмость имени массива (длина > 0 символов и начальный символ БУКВА)
   t_printf( err_01, Res );
   longjmp( env_BypassMacro, 1 ); // нелокальный переход к точке setjmp !!!!!!!
  }
//
////////////////////////////////////////////////////////////////////////////////
  strReplace( w, sizeof(w)-1, indexMass, strTmp.assign(1,cI).c_str(), "X[0]" ); // замена строки cI на X[0]
//
  if( Get_CountOperandsByInstruction( SetName ) == 1 ) // 1 операнд в инструкции
   sprintf( w, "%s %s, %s[%d] ; %s", SetName, Opd_1, nameMass, // формируем изменённое поле результата
                                     (INT)pcExpression( w, (double)i,0.0 ), Comm );
  else
   sprintf( w, "%s %s, %s, %s[%d] ; %s", SetName, Opd_1,Opd_2, nameMass, // формируем изменённое поле результата
                                         (INT)pcExpression( w, (double)i,0.0 ), Comm );
//
  mExpand->Add( w ); // добавим готовую строку расширения для сохранения
//
} // ----- конец handRes_asMassiv ----------------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall Expansion_1_2_Opd( char *s, int nOpd )
{ // расширяет макрос по инструкции c 1-2 операндами , добавляет расширение в
// mExpand (TStringList) ; nOpd - число операндов
 bool outCode = true; // удачное расширение SET
 int out;
//
 for( INT i=minI; i<=maxI; i+=dI ) // по всему заданному диапазону расширения макроса
 {
////////////////////////////////////////////////////////////////////////////////
// ----- разбираем операнды не SET'а -------------------------------------------
//
  strcpy( str, s ); // копируем, ибо при обработке strtok исходная строка s разрушается
//
  Opd_2[0] = Comm[0] = '\0'; // обнуление...
//
  strcpy( SetName,      p = strtok( str,  " " ) ); // мнемоника
  strcpy( Opd_1,   DAS( p = strtok( NULL, "," ) ) ); // 1-й операнд
  if( nOpd == 2 )
   strcpy( Opd_2,  DAS( p = strtok( NULL, "," ) ) ) ; // 2-й операнд
  strcpy( Res,     DAS( p = strtok( NULL, ";" ) ) ); // результат
//
  if( strchr(s,';') ) // если в строке есть ';'
   strcpy( Comm, &s[strchr(s,';')-s+1] ); // копируем в Comm всё, правее ';'
//
// ------ обрабатываем поле Opd_1 (первый операнд инструкции) ------------------
////////////////////////////////////////////////////////////////////////////////
  if( !strchr(Opd_1, '[') && !strchr(Opd_1,']') ) // в Opd_1 нет и '[' и ']' ---
   handOpd_asValue( Opd_1, i ); // обрабатываем результат, если он простая переменная
  else
   handOpd_asMassiv( Opd_1, i ); // обрабатываем результат, если он псевдомассив
// ------ обрабатываем поле Opd_2 (второй операнд инструкции) ------------------
////////////////////////////////////////////////////////////////////////////////
  if( nOpd  == 2 ) // 2-й операнд
   if( !strchr(Opd_2, '[') && !strchr(Opd_2,']') ) // в Opd_2 нет и '[' и ']' ---
    handOpd_asValue( Opd_2, i ); // обрабатываем результат, если он простая переменная
   else
    handOpd_asMassiv( Opd_2, i ); // обрабатываем результат, если он псевдомассив
////////////////////////////////////////////////////////////////////////////////
// ------ обрабатываем поле Res (результат выполнения инструкции) --------------
////////////////////////////////////////////////////////////////////////////////
  if( !strchr(Res, '[') && !strchr(Res,']') ) // в Res нет и '[' и ']' ---------
   handRes_asValue( Res, i ); // обрабатываем результат, если он простая переменная
  else
   handRes_asMassiv( Res, i ); // обрабатываем результат, если он псевдомассив
////////////////////////////////////////////////////////////////////////////////
//
// ---- собираем готовую строку инструкции из отдельных полей ------------------
  if( nOpd == 1 ) // 1 операнд
   sprintf( str, "%s %s, %s ; %s", SetName, Opd_1, Res, Comm ); // готовим преобразованную строку инструкции
  else
   sprintf( str, "%s %s, %s, %s ; %s", SetName, Opd_1, Opd_2, Res, Comm );
////////////////////////////////////////////////////////////////////////////////
// mExpand->Add( str ); // добавим готовую строку расширения для сохранения
//
 } // конец for( INT i=minI; i<=maxI; i+=dI )
//
} // ---------- конец Expansion_1_2_Opd ----------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall handOpd_asValue( char* Opd, INT i )
{ // обрабатываеи поле результата, если он в форме простой переменной
// результат (Opd_1 или Opd_2) помещается на то же место !
//
 sprintf( w, "%s:%d:%d", Opd, numbFor, i-1 );
 strcpy( Opd, w ); // вернём в том же поле операндов
//
} // ---------- конец handOpd_asValue ------------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall handOpd_asMassiv( char* Opd, INT i )
{ // обрабатываеи поле результата, если он в форме псевдомассива
// результат (Opd_1 или Opd_2) помещается на то же место !
//
  string strTmp;
//
  strcpy( nameMass,  p = strtok( Opd,  "[" ) ); // строка до '['
  strcpy( indexMass, p = strtok( NULL, "]" ) ); // строка от '[' до ']' (собственно индекс)
////////////////////////////////////////////////////////////////////////////////
//
  if( !permissName(nameMass) )
  { // проверка на допустИмость имени массива (длина > 0 символов и начальный символ БУКВА)
   t_printf( err_01, Opd );
   longjmp( env_BypassMacro, 1 ); // нелокальный переход к точке setjmp !!!!!!!
  }
//
////////////////////////////////////////////////////////////////////////////////
  strReplace( w, sizeof(w)-1, indexMass, strTmp.assign(1,cI).c_str(), "X[0]" ); // замена строки cI на X[0]
//
  sprintf( Opd, "%s[%d]", nameMass, (INT)pcExpression( w, (double)i,0.0 ), Comm );
//
} // ---------- конец handOpd_asMassiv -----------------------------------------



