//
void   __fastcall Expansion_SET_1D( char* s ); // расширение макроса препроцессором (инструкция SET)
void   __fastcall Expansion_SET_2D( char* s );
void   __fastcall Expansion_1_2_Opd_1D( char* s, int nOpd ); // обработка инструкции с 1-2 операндами
void   __fastcall Expansion_1_2_Opd_2D( char* s, int nOpd );
void   __fastcall SelectInstrForMacrosExpans_1D(); // выбор типа инструкции для расширения препроцессором
void   __fastcall SelectInstrForMacrosExpans_2D(); // выбор типа инструкции для расширения препроцессором
double __fastcall pcExpression( char* Expression, double Value_1, double Value_2 ); // вычислить и вернуть double
int    __fastcall testIndex(char* str, char chr ); // возвращает число не 'chr' символов
//
void   __fastcall handOpd_asVariable_1D( char* Opd, INT i ); // // обработка поля-операнда в виде переменной (не псевдомассива)
void   __fastcall handRes_asVariable_1D( char* Res, INT i ); // обработка поля-результата в виде переменной (не псевдомассива)
void   __fastcall handOpd_asMassive_1D(  char* Opd, INT i ); // // обработка поля-операнда в виде 1D-псевдомассива
void   __fastcall handRes_asMassive_1D(  char* Res, INT i ); // обработка поля-результата в форме 1D-псевдомассива
//\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
void   __fastcall handOpd_asVariable_2D( char* Opd, INT i, INT j ); // // обработка поля-операнда в виде 2D-переменной (не псевдомассива)
void   __fastcall handRes_asVariable_2D( char* Opd, INT i, INT j ); // // обработка поля-результата в виде 2D-переменной (не псевдомассива)
void   __fastcall handOpd_asMassive_2D(  char* Opd, INT i, INT j ); // // обработка поля-операнда в виде 2D-псевдомассива
void   __fastcall handRes_asMassive_2D(  char* Res, INT i, INT j ); // обработка поля-результата в форме 2D-псевдомассива
//
void   __fastcall replace_Str( char* s, const char* sOld, const char* sNew ); // замена cI на sNew в строке s
bool   __fastcall makeMassive_1D( char* str, INT i ); // находит и обрабатывает (расширяет) макросы в 1D-псевдомассивы
bool   __fastcall makeMassive_2D( char* str, INT i ); // ...2D-псевдомассивы
void   __fastcall tf_printf( char* str ); // вывод строки str во фрейм протокола и файл fptrOut (global)
//
#define _tf_printf(str) t_printf("%s",str);fprintf(fptrOut,"%s\n",str); // макрос вывода строки str во фрейм протокола и файл fptr
// ограничения на имена переменных: "длина>0" и "первый символ - буква" или "первый=attrvar"
#define permissName(str) ( strlen(str)&&(isalpha(str[0])||!memcmp(str,attrVar,strlen(attrVar)) ) ) // длина>0 'и' (первая=буква 'или' первые!=attrVar)
//
#define test_1D(s) ( strchr(s,'[') && strchr(s,']') && /* символы '[' и ']' присутствуют в строке s */ \
               (int)(strchr(s,'[')-s)>=1 && /* символ '[' не первый в строке s */ \
               (int)(strchr(s,']')-strchr(s,'['))>=1 ) // между '[' и ']' не менее одного символа
//
#define test_2D(s) ( strchr(s,'[') && strchr(s,':') && strchr(s,']') && /* символы '[', ':' и ']' присутствуют в строке s */ \
               (int)(strchr(s,'[')-s)>=1 && /* символ '[' не первый в строке s */ \
               (int)(strchr(s,':')-strchr(s,'['))>=1 && /*  между '[' и '[' не менее одного символа */ \
               (int)(strchr(s,']')-strchr(s,':'))>=1 ) // между ';' и ']' не менее одного символа
//
// makeMassive_1D, makeMassive_2D - обработчик ("расширитель") макроса в 1D- и 2D-псевдомассивы
// handOpd_asMassive_1D (2D) - обработчик поля операнда как 1D (2D) - массив (псевдомасстив)
// handOpd_asVariable_1D (2D)  - -.-.-.- как простая переменная
// handRes_asMassive_1D (2D) - обработчик поля результата как 1D (2D) - массив (псевдомассив)
// handRes_asVariable_1D (2D)  - -.-.-.- как простая переменная
//
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall tf_printf( char* str )
{ // вывод строки str во фрейм протокола + в файл fptrOut (global)
 t_printf( "%s", str );
 fprintf( fptrOut, "%s\n", str );
} // ----- конец tf_printf -----------------------------------------------------

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
bool __fastcall Process_Macros()
{ // читаем инструкции из файла FileNameSet, ищем заголвки макросов, запоминаем
// тела макросов в mBody (тип TStringList), вызываем обработчик макросов и создаём
// новый файл с полным текстом (расщирения макросов)
 char str[_1024]="\0", strSave[_1024]="\0"; // строка для считывания и расшифровки инструкций + сохранение исходной строки
//
 flagMacroTitle_1D = flagMacroTitle_2D = false ; // !!!!!! вначале (global) !!!!!
//
 if( !(fptrIn = fopen( FileNameSet, "r") ) ) // файл fptrIn (global) открыть не удалось...
  return false;
//
 strcpy( FileNameSetPrP, ChangeFileExt(FileNameSet,ExtPrP).c_str() ); // имя файла инструкций после препроцессора
 if( !(fptrOut = fopen( FileNameSetPrP, "w") ) ) // файл инструкций после препроцессора fptrOut (global) открыть не удалось...
  return false;
//
////////////////////////////////////////////////////////////////////////////////
//
 for( INT i=0; i<max_Instruction; i++ ) // по строкам инструкций
  {
//
   if(fgets(str, sizeof(str), fptrIn) == NULL) // читаем строку из fptr
    break; // если строки кончились, функция fgets возвращает NULL
//
   strcpy( strSave, str ); // сохраним исходную строку
//
   if(str[strlen(str)-1] == 10) // если в конце символ новой строки (10) в десятичной)...
    str[strlen(str)-1] = ' ';   // ... то заменим на пробел !
//
// ----- все Tab в строке str заменяем на пробелы ------------------------------
   for( INT i=0; i<strlen(str); i++ ) // по всем символам строки...
    if( str[i] == VK_TAB ) // если i-тый символ есть Tab (9/0x9)...
     str[i] = VK_SPACE; // то заменяем его на пробел (32/0x20) !
//
   DSTA( str ); // чистка строки str от лидирующих и терминирующих Tabs и  пробелов
//
   if( !strlen(str) || // если длина строки нулевая...
       str[0]==startComments[0] || // или строка начинается с ";"...
       str[0]==';' ) // частая описка ( ':' вместо ";" )
    goto cont;
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
  i_env_BypassMacro = setjmp( env_BypassMacro ); // установили точку перехода
  if( i_env_BypassMacro ) // не ноль - значит, сюда был прыжок !!!!!!!!!!!!!!!!!
   goto label_BypassMacro;
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
   if( !makeMassive_1D( str, i ) ||  // расширение макроса в 1D-псевдомассив
//    continue; // строка str в выходной файл fptrOut добавляться не будет
       !makeMassive_2D( str, i ) ) // ...в 2D-псевдомассив
    continue; // строка str в выходной файл fptrOut добавляться не будет
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////
label_BypassMacro: // сюда переходим по longjmp --------------------------------
////////////////////////////////////////////////////////////////////////////////
cont: // для прОпуска строки с возможностью копирования в файл FileNameSetPrP --
////////////////////////////////////////////////////////////////////////////////
// ----- добавляем строки в выходной файл FileNameSetPrP -----------------------
 fputs( strSave, fptrOut ); // сохраняем строку исходного файла
//
 } // конец цикла i по строкам в файле FileNameSets
////////////////////////////////////////////////////////////////////////////////
//
 fclose( fptrIn  ); // закрываем все открытые файлы
 fclose( fptrOut );
//
 return 0; // всё Ok
//
} // --------- конец Process_Macros --------------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
bool __fastcall makeMassive_1D( char* str, INT i )
{ // находит и обрабатывает (расширяет) макрос в 1D-псевдомассивы --------------
// при возврате false строка str в выходной файл добавляться не будет ! --------
  if( !strncmp( str, "for[", 4 ) && // если в начале str находится 'for[' (первые 4 символа) 'и'
       sscanf( str, "for[%c]=%d,%d,%d{", &cI, &minI,&maxI,&dI ) == 4 ) // все 4 поля корректно прочитаны..!
  { // начало if( !strncmp( str, "for[", 4 ) && ...
//
   if( !dI || // неверен диапазон изменения переменных цикла (приводит к  беконечному повтору )
     (  maxI>=minI && dI<=0) || ( maxI<=minI && dI>=0) )
   {
    t_printf( "\n-M- Некорректен диапазон изменения [%d,%d,%d] переменной цикла '%c' -M-\n", minI,maxI,dI,cI );
    return false; // строка str в выходной файл fptrOut добавляться не будет
   }
//
   for_ID ++ ; // номер for[... в данной программе
   flagMacroTitle_1D = true; // нашли строку с заголовком 1D-макроса
   mBody->Clear(); // очистили mBody типа TStringList
   mBody->Add( str ); // запомнили заголовок 1D-макроса
   mExpand->Clear(); // готовимся к заполнению строка расширения макроса !!!
   return false; // строка str в выходной файл fptrOut добавляться не будет
  } // конец if( !strncmp( str, "for[", 4 ) && ...
//
  if( flagMacroTitle_1D && str[0] != '}' ) // пока не было "}" в строке имеем flagMacroTitle=true
  {
   mBody->Add( str ); // добавляем в mBody строки макроса
   return false; // строка str в выходной файл fptrOut добавляться не будет
  }
//
  if( flagMacroTitle_1D && str[0] == '}' ) // после заголовка макроса в строке встретился "}"
  {
   flagMacroTitle_1D = false; // в строке встретился "}"
   mBody->Add( str ); // добавляем в mBody строку "}"
//   endN = i; // запомним номер строки с последним символом макроса
//
////////////////////////////////////////////////////////////////////////////////
   SelectInstrForMacrosExpans_1D(); // выбор типа инструкции для расширения препроцессором
////////////////////////////////////////////////////////////////////////////////
   tf_printf( Format("; \n; начало расширения макроса: заголовок 'for[%s]=%d,%d,%d {'\n; for_ID: %d", // cI -> %s !!!
              OPENARRAY(TVarRec,(cI, int(minI), int(maxI),int(dI), int(for_ID)))).c_str() );
   for( int j=0; j<mBody->Count; j++ )
    tf_printf( Format("; %s", OPENARRAY(TVarRec, (mBody->Strings[j].c_str()) )).c_str() );
   for( int j=0; j<mExpand->Count; j++ ) // добавление расширения на псевдо-массивы
    tf_printf( Format("%s",  OPENARRAY(TVarRec, (mExpand->Strings[j].c_str()) )).c_str() );
   tf_printf( Format("; \n; конец расширения макроса: заголовок 'for[%s]=%d,%d,%d {'\n;", // cI -> %s !!!
              OPENARRAY(TVarRec,(cI, int(minI),int(maxI),int(dI)))).c_str() );
////////////////////////////////////////////////////////////////////////////////
   return false; // строка str в выходной файл fptrOut добавляться не будет
  }
//
} // ------ конец makeMassive_1D -----------------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall replace_Str( char* s, const char* sOld, const char* sNew )
{ // все вхождения sOld (кроме как в именах стандартных функций stdFunc) в s заменяются на sNew
//
 string strTmp;
//
// ------ замена stdFunc[] -----------------------------------------------------
 for( int i=0; i<sizeof(stdFunc)/sizeof(stdFunc[0]); i++ ) // по названиям стандартных функций парсера
 {
  strReplace( expr, sizeof(expr)-1, s, stdFunc[i], Format( replaceFmt,OPENARRAY(TVarRec,(i))).c_str() );
  strcpy( s, expr );
 } // конец for( int i=0; i<sizeof(stdFunc)/sizeof(stdFunc[0]); i++ )
//
 for( int ii=10; ii>=2; ii-- ) // проверка на наличие ii последовательных cI
  if( strstr( s, strTmp.assign(ii,cI).c_str() ) )
  {
   t_printf( "\n-M- В строке [%s] для вычислений встречен многократный (%d) повтор индекса '%c' -M-\n", s,ii,cI );
   longjmp( env_BypassMacro, 1 ); // нелокальный переход к точке setjmp !!!!!!!
  }
//
 strReplace( expr, sizeof(expr)-1, s, sOld, sNew ); // замена строки sOld на строку sNew (обычно cI на X[0])
//
 strcpy( s, expr ); // готовимся к восстанвлению строки ---------------------------
//
// ------ восстановление stdFunc[] ---------------------------------------------
 for( int i=0; i<sizeof(stdFunc)/sizeof(stdFunc[0]); i++ ) // по названиям стандартных функций парсера
 {
   strReplace( expr, sizeof(expr)-1, s, Format( replaceFmt,OPENARRAY(TVarRec,(i))).c_str(), stdFunc[i] );
   strcpy( s, expr );
 } // конец for( int i=0; i<sizeof(stdFunc)/sizeof(stdFunc[0]); i++ )
//
} // ------ конец replace_Str --------------------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
double __fastcall pcExpression( char* Expression, double Value_1, double Value_2 )
{ // парсеринг и вычисление выражения Expression от двух переменных Value_1/Value_2
//
 try
 {
  parser.Compile( Expression ); // разборка выражения
  parser.Evaluate( Value_1, Value_2 ); // точка вычисления по переменным X[0],X[1] etc
  return parser.GetResult(); // возвращаем double !!!
 }
 catch(TError error)
 {
  if( flagAlarmParser ) // выдать предупреждение (global)
  {
   MessageBeep( MB_OK ); // звуковое предупреждение...
   snprintf( str,sizeof(str), "ПРЕПРОЦЕССОР: проблема разборки выражения\n\n[%s]" // str - global
                              "\n\nОШИБКА: [%s] в позиции %d",
             Expression, error.error, error.pos );
   MessageBox(0, str, " Ошибка !", MB_OK);
//
   flagAlarmParser = false; // global..!
  } // и больше не выдавать..!
//
 } // конец catch( )
//
} // -------- конец pcExpression -----------------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
int __fastcall testIndex(char* str, char chr )
{ // если в строке str кроме БУКВЫ 'chr' встречаются и иные БУКВЫ, выдаётся число встреч
//
 int count = 0;
//
 for( int i=0; i<strlen(str); i++ ) // по всей строке str
  if( isalpha(str[i]) && str[i] !=chr ) // если БУКВА и НЕ 'chr'
   count++;
//
 return count;
//
} // ------ конец testIndex ----------------------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall SelectInstrForMacrosExpans_1D()
{ // выбор типа инструкции макроса для расширения препроцессором
//
// char Set[4]; // имя мнемоники инструкции
//
 for( int j=1; j<mBody->Count-1; j++ ) // цикл по строкам содержания макроса (кроме заголовка и последней)
 {
  strncpy( SetName, mBody->Strings[j].c_str(), 3 ); // запомнили мнемонику инструкции (3 первых символа)
  strupr( SetName ); // переводим в заглавные для корректности сравнения
//
  if( !strcmp( SetName, "SET") ) // это SET ..!
   Expansion_SET_1D( mBody->Strings[j].c_str() ); // расширяет макрос по инструкции SET
  else // это не SET (1-2 операнда в инструкции)
   Expansion_1_2_Opd_1D( mBody->Strings[j].c_str(), Get_CountOperandsByInstruction( SetName ) );
 }
//
} // --------- конец SelectInstrForMacrosExpans_1D -----------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall SelectInstrForMacrosExpans_2D()
{ // выбор типа инструкции макроса для расширения препроцессором
//
// char Set[4]; // имя мнемоники инструкции
//
 for( int j=1; j<mBody->Count-1; j++ ) // цикл по строкам содержания макроса (кроме заголовка и последней)
 {
  strncpy( SetName, mBody->Strings[j].c_str(), 3 ); // запомнили мнемонику инструкции (3 первых символа)
  strupr( SetName ); // переводим в заглавные для корректности сравнения
//
  if( !strcmp( SetName, "SET") ) // это SET ..!
   Expansion_SET_2D( mBody->Strings[j].c_str() ); // расширяет макрос по инструкции SET
  else // это не SET (1-2 операнда в инструкции)
   Expansion_1_2_Opd_2D( mBody->Strings[j].c_str(), Get_CountOperandsByInstruction( SetName ) );
 }
//
} // --------- конец SelectInstrForMacrosExpans_2D -----------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall handOpd_asVariable_1D( char* Opd, INT i )
{ // обрабатываеи поле операнда, если он в форме простой переменной
// результат (Opd_1 или Opd_2) помещается на то же место !
//
 if( TokenUse ) // использовать токен для имени операнда Opd
 {
  char tmp[_1024];
  sprintf( tmp, "%s:%d:%d", Opd, for_ID, i ); // имя переменной + for_ID + i (токен)
  strcpy( Opd, tmp );
 }
//
} // ---------- конец handOpd_asVariable_1D ---------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall handOpd_asMassive_1D( char* Opd, INT i )
{ // обрабатываеи поле результата, если он в форме 1D-псевдомассива
// результат (Opd_1 или Opd_2) помещается на то же место !
//
  string strTmp;
//
  strcpy( nameMass,  p = strtok( Opd,  "[" ) ); // строка до '['
  strcpy( indexMass, p = strtok( NULL, "]" ) ); // строка от '[' до ']' (собственно индекс)
////////////////////////////////////////////////////////////////////////////////
//
  if( !permissName(nameMass) )
  { // проверка на допустИмость имени массива (длина > 0 символов и начальный символ БУКВА)
   t_printf( err_01, Opd );
   longjmp( env_BypassMacro, 1 ); // нелокальный переход к точке setjmp !!!!!!!
  }
//
////////////////////////////////////////////////////////////////////////////////
  strReplace( expr, sizeof(expr)-1, indexMass, strTmp.assign(1,cI).c_str(), "X[0]" ); // замена строки cI на X[0]
//
  sprintf( Opd, "%s[%d]", nameMass, (INT)pcExpression( expr, (double)i,0.0 ), Comm );
//
} // ---------- конец handOpd_asMassive_1D -------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
bool __fastcall makeMassive_2D( char* str, INT i )
{ // находит и обрабатывает (расширяет) макрос в 2D-псевдомассивы --------------
//
  if( !strncmp( str, "for[", 4 ) && // если в начале str находится 'for[' (первые 4 символа) 'и'
       sscanf( str, "for[%c:%c]=%d,%d,%d:%d,%d,%d{", &cI,&cJ,&minI,&maxI,&dI, // все 8 полей корректно прочитаны..!
                                                             &minJ,&maxJ,&dJ ) == 8 )
  { // начало if( !strncmp( str, "for[", 4 ) && ...
//
   if( !dI || // неверен диапазон изменения переменных цикла I (приводит к беконечному повтору )
     (  maxI>=minI && dI<=0) || ( maxI<=minI && dI>=0) )
   {
    t_printf( "\n-M- Некорректен диапазон изменения [%d,%d,%d] переменной цикла '%c' -M-\n", minI,maxI,dI,cI );
    return false; // строка str в выходной файл fptrOut добавляться не будет
   }
//
   if( !dJ || // неверен диапазон изменения переменных цикла J (приводит к беконечному повтору )
     (  maxJ>=minJ && dJ<=0) || ( maxJ<=minJ && dJ>=0) )
   {
    t_printf( "\n-M- Некорректен диапазон изменения [%d,%d,%d] переменной цикла '%c' -M-\n", minJ,maxJ,dJ,cJ );
    return false;  // строка str в выходной файл fptrOut добавляться не будет
   }
//
   if( cI == cJ ) // одинаковые индексы обоих циклов
   {
    t_printf( "\n-M- Одинаковые индексы вложенных циклов - внешний: '%c' , внутренний: '%c' -M-\n", cI, cJ );
    return false;  // строка str в выходной файл fptrOut добавляться не будет
   }
//
   for_ID ++ ; // номер for[... в данной программе
   flagMacroTitle_2D = true; // нашли строку с заголовком 1D-макроса
   mBody->Clear(); // очистили mBody типа TStringList
   mBody->Add( str ); // запомнили заголовок 1D-макроса
   mExpand->Clear(); // готовимся к заполнению строка расширения макроса !!!
   return false;  // строка str в выходной файл fptrOut добавляться не будет
  } // конец if( !strncmp( str, "for[", 4 ) && ...
//
  if( flagMacroTitle_2D && str[0] != '}' ) // пока не было "}" в строке имеем flagMacroTitle=true
  {
   mBody->Add( str ); // добавляем в mBody строки макроса
   return false; // строка str в выходной файл fptrOut добавляться не будет
  }
//
  if( flagMacroTitle_2D && str[0] == '}' ) // после заголовка макроса в строке встретился "}"
  {
   flagMacroTitle_2D = false; // в строке встретился "}"
   mBody->Add( str ); // добавляем в mBody строку "}"
//
////////////////////////////////////////////////////////////////////////////////
   SelectInstrForMacrosExpans_2D(); // выбор типа инструкции для расширения препроцессором
////////////////////////////////////////////////////////////////////////////////
   tf_printf( Format("; \n; начало расширения макроса: заголовок 'for[%s:%s]=%d,%d,%d:%d,%d,%d {'\n; for_ID: %d", // cI -> %s !!!
              OPENARRAY(TVarRec,(cI,cJ, int(minI),int(maxI),int(dI), int(minJ),int(maxJ),int(dJ), int(for_ID)))).c_str() );
   for( int j=0; j<mBody->Count; j++ )
    tf_printf( Format("; %s", OPENARRAY(TVarRec, (mBody->Strings[j].c_str()) )).c_str() );
   for( int j=0; j<mExpand->Count; j++ ) // добавление расширения на псевдо-массивы
    tf_printf( Format("%s",  OPENARRAY(TVarRec, (mExpand->Strings[j].c_str()) )).c_str() );
   tf_printf( Format("; \n; конец расширения макроса: заголовок 'for[%s:%s]=%d,%d,%d:%d,%d,%d {'\n;", // cI -> %s !!!
              OPENARRAY(TVarRec,(cI,cJ, int(minI),int(maxI),int(dI),  int(minJ),int(maxJ),int(dJ) ))).c_str() );
////////////////////////////////////////////////////////////////////////////////
    return false;  // строка str в выходной файл fptrOut добавляться не будет
  }
//
} // ------ конец makeMassive_2D -----------------------------------------------

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall Expansion_SET_1D( char* s )
{ // расширяет макрос по инструкции SET , добавляет расширение в mExpand (TStringList)
//
 int out;
 string strTmp;
 char tmp_1[_512], tmp_2[_512]; // локальные массивы
//
// ----- разбираем 1-й операнд SET'а -------------------------------------------
//
  Comm[0] = '\0'; // обнуление...
//
  strcpy( str, s ); // копируем, ибо при обработке strtok исходная строка s разрушается
  strcpy( SetName,      p = strtok( str,  " " ) ); // мнемоника
  strcpy( Opd_1,   DAS( p = strtok( NULL, "," ) ) ); // 1-й операнд
  strcpy( Res,     DAS( p = strtok( NULL, ";" ) ) ); // результат
//
  strcpy( tmp_1,  Opd_1 ); // запомниди Opd_1
  strcpy( tmp_2,  Res ); // запомнили Res
//
  if( strchr(s,';') ) // если в строке есть ';'
   strcpy( Comm, &s[strchr(s,';')-s+1] ); // копируем в Comm всё правее ';'
//
 for( INT i=minI; i<=maxI; i+=dI ) // по всему заданному диапазону расширения макроса
 {
  strcpy( Opd_1, tmp_1 ); // восстановили Opd_1
  strcpy( Res,   tmp_2 ); // восстановили Res
//
  replace_Str( Opd_1, strTmp.assign(1,cI).c_str(), "X[0]" ); // замена cI на X[0] исключая имена стандартных функций
//
  sprintf( Opd_1, "%.*g", sizeof(Mem_Data[0].Addr)-1, pcExpression( expr, (double)i, 0.0 ) );
// ------ обрабатываем поле Res (результат выполнения инструкции) --------------
  if( test_1D( Res ) )
   handRes_asMassive_1D( Res, i ); // обрабатываем результат, если он 1D-псевдомассив
  else
   handRes_asVariable_1D( Res, i ); // обрабатываем результат, если он простая переменная
//
// ---- собираем готовую строку инструкции из отдельных полей ------------------
//
  sprintf( str, "%s %s, %s ; %s", SetName, Opd_1, Res, Comm ); // готовим инструкцию для расширения
//
  mExpand->Add( str ); // добавим готовую инструкцию строку для временного хранения
//
 } // конец по i (по числу строк расширения) ===================================
//
} // ---------- конец Expansion_SET_1D -----------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall Expansion_SET_2D( char* s )
{ // расширяет макрос по инструкции SET , добавляет расширение в mExpand (TStringList)
//
 int out;
 string strTmp;
 char tmp_1[_512], tmp_2[_512]; // локальные массивы
//
// ----- разбираем 1-й операнд SET'а -------------------------------------------
//
  Comm[0] = '\0'; // обнуление...
//
  strcpy( str, s ); // копируем, ибо при обработке strtok исходная строка s разрушается
  strcpy( SetName,      p = strtok( str,  " " ) ); // мнемоника
  strcpy( Opd_1,   DAS( p = strtok( NULL, "," ) ) ); // 1-й операнд
  strcpy( Res,     DAS( p = strtok( NULL, ";" ) ) ); // результат
//
  strcpy( tmp_1, Opd_1 ); // запомниди Opd_1
  strcpy( tmp_2, Res ); // запомнили Res
//
  if( strchr(s,';') ) // если в строке есть ';'
   strcpy( Comm, &s[strchr(s,';')-s+1] ); // копируем в Comm всё правее ';'
//
 for( INT i=minI; i<=maxI; i+=dI ) // по всему заданному диапазону i расширения макроса
 for( INT j=minJ; j<=maxJ; j+=dJ ) // по всему заданному диапазону j расширения макроса
 {
  strcpy( Opd_1, tmp_1 ); // восстановили Opd_1
  strcpy( Res,   tmp_2 ); // восстановили Res
//
  replace_Str( Opd_1, strTmp.assign(1,cI).c_str(), "X[0]" ); // замена cI на X[0] исключая имена стандартных функций
  replace_Str( Opd_1, strTmp.assign(1,cJ).c_str(), "X[1]" ); // замена cJ на X[1] ...
//
  sprintf( Opd_1, "%.*g", sizeof(Mem_Data[0].Addr)-1, pcExpression( expr, (double)i, double(j) ) ); // Оpd_1, w - глобал..1
// ------ обрабатываем поле Res (результат выполнения инструкции) --------------
  if( test_2D( Res ) )
   handRes_asMassive_2D( Res, i, j ); // обрабатываем результат, если он 2D-псевдомассив
  else
   handRes_asVariable_2D( Res, i, j ); // обрабатываем результат, если он простая переменная
//
// ---- собираем готовую строку инструкции из отдельных полей ------------------
  sprintf( str, "%s %s, %s ; %s", SetName, Opd_1, Res, Comm ); // готовим преобразованную строку инструкции
////////////////////////////////////////////////////////////////////////////////
  mExpand->Add( str ); // добавим готовую строку расширения для сохранения
//
 } // конец по i,j (по числу строк и столбцов расширения) ======================
//
} // ---------- конец Expansion_SET_2D -----------------------------------------

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall handRes_asVariable_2D( char* Res, INT i, INT j )
{ // обрабатываем поле результата, если он в форме простой переменной ----------
//
  if( TokenUse ) // использовать токен для имени результата
  {
   char tmp[_1024];
   sprintf( tmp, "%s:%d:%d:%d", Res, for_ID, i, j );
   strcpy( Res, tmp ); // подготовили строку результата выполнения инструкции
  }
//
} // ----- конец handRes_asVariable_2D --------------------------------------------

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall Expansion_1_2_Opd_1D( char* s, int nOpd )
{ // расширяет макрос по инструкции c 1-2 операндами , добавляет расширение в
// mExpand (TStringList) ; nOpd - число операндов
// bool outCode = true; // удачное расширение SET
 int out;
 char tmp_1[_512], tmp_2[_512], tmp_3[_512]; // локальные массивы
//
  strcpy( str, s ); // копируем, ибо при обработке strtok исходная строка s разрушается
//
  Opd_2[0] = Comm[0] = '\0'; // обнуление...
//
  strcpy( SetName,      p = strtok( str,  " " ) ); // мнемоника
  strcpy( Opd_1,   DAS( p = strtok( NULL, "," ) ) ); // 1-й операнд
  if( nOpd == 2 )
   strcpy( Opd_2,  DAS( p = strtok( NULL, "," ) ) ) ; // 2-й операнд
  strcpy( Res,     DAS( p = strtok( NULL, ";" ) ) ); // результат
//
  if( strchr(s,';') ) // если в строке есть ';'
   strcpy( Comm, &s[strchr(s,';')-s+1] ); // копируем в Comm всё, правее ';'
//
  strcpy( tmp_1, Opd_1 ); // сохраняем строки
  strcpy( tmp_2, Opd_2 );
  strcpy( tmp_3, Res );
//
 for( INT i=minI; i<=maxI; i+=dI ) // по заданному i-диапазону расширения 1D-макроса
 {
// ----- разбираем операнды не SET'а -------------------------------------------
  strcpy( Opd_1, tmp_1 ); // востанавливаем строки
  strcpy( Opd_2, tmp_2 );
  strcpy( Res,   tmp_3 );
//
// ------ обрабатываем поле Opd_1 (первый операнд инструкции) ------------------
  if( test_1D( Opd_1 ) )
   handOpd_asMassive_1D( Opd_1, i ); // обрабатываем результат, если он 1D-псевдомассив
  else
   handOpd_asVariable_1D( Opd_1, i ); // обрабатываем результат, если он простая переменная
//
// ------ обрабатываем поле Opd_2 (второй операнд инструкции) ------------------
//
  if( nOpd == 2 ) // 2-й операнд
   if( test_1D( Opd_1 ) )
    handOpd_asMassive_1D( Opd_2, i ); // обрабатываем результат, если он 1D-псевдомассив
   else
    handOpd_asVariable_1D( Opd_2, i ); // обрабатываем результат, если он простая переменная
//
// ------ обрабатываем поле Res (результат выполнения инструкции) --------------
  if( test_1D( Res ) )
   handRes_asMassive_1D( Res, i ); // обрабатываем результат, если он 1D-псевдомассив
  else
   handRes_asVariable_1D( Res, i ); // обрабатываем результат, если он простая переменная
//
// ---- собираем готовую строку инструкции из отдельных полей ------------------
  if( nOpd == 1 ) // 1 операнд
   sprintf( str, "%s %s, %s ; %s", SetName, Opd_1, Res, Comm ); // готовим преобразованную строку инструкции
  else
   sprintf( str, "%s %s, %s, %s ; %s", SetName, Opd_1,Opd_2, Res, Comm );
////////////////////////////////////////////////////////////////////////////////
//
  mExpand->Add( str ); // добавим готовую строку расширения для сохранения
//
 } // конец цикла по i
//
} // ---------- конец Expansion_1_2_Opd_1D -------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall handRes_asMassive_1D( char* Res, INT i )
{ // обрабатываеи поле результата, если он в форме 1D-псевдомассива ------------
//
  string strTmp;
//
  strcpy( nameMass,  p = strtok( Res,  "[" ) ); // строка до '['
  strcpy( indexMass, p = strtok( NULL, "]" ) ); // строка от '[' до ']'
////////////////////////////////////////////////////////////////////////////////
//
  if( !permissName(nameMass) )
  { // проверка на допустИмость имени массива (длина > 0 символов и начальный символ БУКВА)
   t_printf( err_01, Res );
   longjmp( env_BypassMacro, 1 ); // нелокальный переход к точке setjmp !!!!!!!
  }
//
////////////////////////////////////////////////////////////////////////////////
  strReplace( expr, sizeof(expr)-1, indexMass, strTmp.assign(1,cI).c_str(), "X[0]" ); // замена строки cI на X[0]
//
  sprintf( Res, "%s[%d]", nameMass, (INT)pcExpression( expr, (double)i,0.0 ) );
//
} // ----- конец handRes_asMassive_1D ------------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall handRes_asVariable_1D( char* Res, INT i )
{ // обрабатываеи поле результата, если он в форме простой переменной ----------
//
  if( TokenUse ) // использовать токен для имени результата
  {
   char tmp[_1024];
   sprintf( tmp, "%s:%d:%d", Res, for_ID, i );
   strcpy( Res, tmp ); // готовая строка результата в форме простой переменной
  }
//
} // ----- конец handRes_asVariable_1D -----------------------------------------

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall Expansion_1_2_Opd_2D( char* s, int nOpd )
{ // расширяет макрос по инструкции c 1-2 операндами , добавляет расширение в
// mExpand (TStringList) ; nOpd - число операндов
// bool outCode = true; // удачное расширение SET
 int out;
 char tmp_1[_512], tmp_2[_512], tmp_3[_512]; // локальные массивы
//
  strcpy( str, s ); // копируем, ибо при обработке strtok исходная строка s разрушается
//
  Opd_2[0] = Comm[0] = '\0'; // обнуление...
//
  strcpy( SetName,      p = strtok( str,  " " ) ); // мнемоника
  strcpy( Opd_1,   DAS( p = strtok( NULL, "," ) ) ); // 1-й операнд
  if( nOpd == 2 )
   strcpy( Opd_2,  DAS( p = strtok( NULL, "," ) ) ) ; // 2-й операнд
  strcpy( Res,     DAS( p = strtok( NULL, ";" ) ) ); // результат
//
  if( strchr(s,';') ) // если в строке есть ';'
   strcpy( Comm, &s[strchr(s,';')-s+1] ); // копируем в Comm всё, правее ';'
//
  strcpy( tmp_1, Opd_1 ); // сохраняем строки
  strcpy( tmp_2, Opd_2 );
  strcpy( tmp_3, Res );
//
 for( INT i=minI; i<=maxI; i+=dI ) // по заданному i-диапазону расширения 2D-макроса
 for( INT j=minJ; j<=maxJ; j+=dJ ) // по заданному j-диапазону расширения 2D-макроса
 {
  strcpy( Opd_1, tmp_1 ); // сохраняем строки
  strcpy( Opd_2, tmp_2 );
  strcpy( Res,   tmp_3 );
//
// ------ обрабатываем поле Opd_1 (первый операнд инструкции) ------------------
  if( test_2D( Opd_1 ) )
   handOpd_asMassive_2D( Opd_1, i, j ); // обрабатываем результат, если он 1D-псевдомассив
  else
   handOpd_asVariable_2D( Opd_1, i, j ); // обрабатываем результат, если он простая переменная
//
// ------ обрабатываем поле Opd_2 (второй операнд инструкции) ------------------
//
  if( nOpd == 2 ) // 2-й операнд
   if( !strchr(Opd_2, '[') && !strchr(Opd_2,']') ) // в Opd_2 нет и '[' и ']' ---
    handOpd_asVariable_2D( Opd_2, i, j ); // обрабатываем результат, если он простая переменная
   else
    handOpd_asMassive_2D( Opd_2, i, j ); // обрабатываем результат, если он 2D-псевдомассив
////////////////////////////////////////////////////////////////////////////////
// ------ обрабатываем поле Res (результат выполнения инструкции) --------------
  if( test_2D( Res ) )
   handRes_asMassive_2D( Res, i, j ); // обрабатываем результат, если он 2D-псевдомассив
  else
   handRes_asVariable_2D( Res, i, j ); // обрабатываем результат, если он простая переменная
//
// ---- собираем готовую строку инструкции из отдельных полей ------------------
  if( nOpd == 1 ) // 1 операнд
   sprintf( str, "%s %s, %s ; %s", SetName, Opd_1, Res, Comm ); // готовим преобразованную строку инструкции
  else
   sprintf( str, "%s %s, %s, %s ; %s", SetName, Opd_1, Opd_2, Res, Comm );
////////////////////////////////////////////////////////////////////////////////
  mExpand->Add( str ); // добавим готовую строку расширения для сохранения
//
 } // конец цикла по i,j (по числу строк и столбцов расширения) ================
//
} // ---------- конец Expansion_1_2_Opd_2D -------------------------------------

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall handOpd_asVariable_2D( char* Opd, INT i, INT j )
{ // обрабатываеи поле операнда, если он в форме простой переменной
// результат (Opd_1 или Opd_2) помещается на то же место !
//
 if( TokenUse ) // использовать токен для имени операнда Opd
 {
  char tmp[_1024];
  sprintf( tmp, "%s:%d:%d:%d", Opd, for_ID, i, j ); // имя переменной + for_ID + i + j (токен)
  strcpy( Opd, tmp );
 }
//
} // ---------- конец handOpd_asVariable_2D ---------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall handRes_asMassive_2D( char* Res, INT i, INT j )
{ // обрабатываеи поле результата, если он в форме 2D-псевдомассива ------------
//
  string strTmp;
  char tmp_1[_512], tmp_11[_512], tmp_2[_512], tmp_22[_512]; // локальные массивы
//
  strcpy( nameMass,    p = strtok( Res,  "[" ) ); // строка до '['
  strcpy( indexMass_1, p = strtok( NULL,  ":" ) ); // строка от '[' до ':'
  strcpy( indexMass_2, p = strtok( NULL, "]" ) ); // строка от ':' до ']'
////////////////////////////////////////////////////////////////////////////////
//
  if( !permissName( nameMass ) )
  { // проверка на допустИмость имени массива (длина > 0 символов и начальный символ БУКВА)
   t_printf( err_01, Res );
   longjmp( env_BypassMacro, 1 ); // нелокальный переход к точке setjmp !!!!!!!
  }
//
////////////////////////////////////////////////////////////////////////////////
//
  strReplace( tmp_1,  sizeof(tmp_1)-1,  indexMass_1, strTmp.assign(1,cI).c_str(), "X[0]" ); // замена в indexMass_1 строки cI на X[0]
  strReplace( tmp_11, sizeof(tmp_11)-1, tmp_1,       strTmp.assign(1,cJ).c_str(), "X[1]" ); // замена строки cJ на X[1]
//
  strReplace( tmp_2,  sizeof(tmp_2)-1,  indexMass_2, strTmp.assign(1,cI).c_str(), "X[0]" ); // замена в indexMass_2 строки cI на X[0]
  strReplace( tmp_22, sizeof(tmp_22)-1, tmp_2,      strTmp.assign(1,cJ).c_str(), "X[1]" ); // замена строки cJ на X[1]
//
  sprintf( Res, "%s[%d:%d]", nameMass, (INT)pcExpression( tmp_11, (double)i, (double)j ),
                                       (INT)pcExpression( tmp_22, (double)i, (double)j ) );
//
} // ----- конец handRes_asMassive_2D ------------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall handOpd_asMassive_2D( char* Opd, INT i, INT j )
{ // обрабатываеи поле результата, если он в форме 2D-псевдомассива
// результат (Opd_1 или Opd_2) помещается на то же место !
//
  string strTmp;
  char tmp_1[_512], tmp_11[_512], tmp_2[_512], tmp_22[_512]; // локальные массивы
//
  strcpy( nameMass,    p = strtok( Opd,  "[" ) ); // строка до '['
  strcpy( indexMass_1, p = strtok( NULL,  ":" ) ); // строка от '[' до ':'
  strcpy( indexMass_2, p = strtok( NULL, "]" ) ); // строка от ':' до ']'
////////////////////////////////////////////////////////////////////////////////
//
  if( !permissName( nameMass ) )
  { // проверка на допустИмость имени массива (длина > 0 символов и начальный символ БУКВА)
   t_printf( err_01, Res );
   longjmp( env_BypassMacro, 1 ); // нелокальный переход к точке setjmp !!!!!!!
  }
//
////////////////////////////////////////////////////////////////////////////////
//
  strReplace( tmp_1,  sizeof(tmp_1)-1,  indexMass_1, strTmp.assign(1,cI).c_str(), "X[0]" ); // замена в indexMass_1 строки cI на X[0]
  strReplace( tmp_11, sizeof(tmp_11)-1, tmp_1,       strTmp.assign(1,cJ).c_str(), "X[1]" ); // замена строки cJ на X[1]
//
  strReplace( tmp_2,  sizeof(tmp_2)-1, indexMass_2, strTmp.assign(1,cI).c_str(), "X[0]" ); // замена в indexMass_2 строки cI на X[0]
  strReplace( tmp_22, sizeof(tmp_22)-1, tmp_2,      strTmp.assign(1,cJ).c_str(), "X[1]" ); // замена строки cJ на X[1]
//
  sprintf( Opd, "%s[%d:%d]", nameMass, (INT)pcExpression( tmp_11, (double)i, (double)j ),
                                       (INT)pcExpression( tmp_22, (double)i, (double)j ) );
//
} // ---------- конец handOpd_asMassive_2D -------------------------------------



