//
void   __fastcall Expansion_SET_1D( char* s ); // расширение макроса препроцессором (инструкция SET)
void   __fastcall Expansion_SET_2D( char* s );
void   __fastcall Expansion_1_2_Opd_1D( char* s, int nOpd ); // обработка инструкции с 1-2 операндами
void   __fastcall Expansion_1_2_Opd_2D( char* s, int nOpd );
void   __fastcall SelectInstrForMacrosExpans_1D(); // выбор типа инструкции для расширения препроцессором
void   __fastcall SelectInstrForMacrosExpans_2D(); // выбор типа инструкции для расширения препроцессором
double __fastcall pcExpression( char* Expression, double Value_1, double Value_2 ); // вычислить и вернуть double
int    __fastcall testIndex(char* str, char chr ); // возвращает число не 'chr' символов
//
void   __fastcall handlXXX_asVariable_1D( char* Field, INT i );
void   __fastcall handlXXX_asMassive_1D(  char* Field, INT i ); // обработка поле Field типа Opd_1,Opd_2,Res для 1D-псевдомассива
//\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
void   __fastcall handlXXX_asVariable_2D( char* Field, INT i, INT j );
void   __fastcall handlXXX_asMassive_2D(  char* Res, INT i, INT j ); // обработка поле Field типа Opd_1,Opd_2,Res для 1D-псевдомассива
//
void   __fastcall replace_Str( char* s, const char* sOld, const char* sNew ); // замена cI на sNew в строке s
bool   __fastcall makeMassive_1D( char* str, INT i ); // находит и обрабатывает (расширяет) макросы в 1D-псевдомассивы
bool   __fastcall makeMassive_2D( char* str, INT i ); // ...2D-псевдомассивы
void   __fastcall tf_printf( char* str ); // вывод строки str во фрейм протокола и файл fptrOut (global)
//
// ограничения на имена переменных: "длина>0" И "первый символ - буква" ИЛИ "первые=attrvar"
#define permissName(str) ( strlen(str) && /* длина>0 'И' */ \
                         ( isalpha(str[0]) || /* первая=буква 'ИЛИ' */ \
                           !memcmp(str,attrVar,strlen(attrVar)) ) ) // первые!=attrVar)
//
#define test_isMassive_1D(s) \
                   ( strchr(s,'[') && strchr(s,']') && /* символы '[' и ']' присутствуют в строке s */ \
               (int)(strchr(s,'[')-s)>=1 && /* символ '[' не первый в строке s */ \
               (int)(strchr(s,']')-strchr(s,'['))>=1 ) // между '[' и ']' не менее одного символа
//
#define test_isMassive_2D(s) \
                   ( strchr(s,'[') && strchr(s,':') && strchr(s,']') && /* символы '[', ':' и ']' присутствуют в строке s */ \
               (int)(strchr(s,'[')-s)>=1 && /* символ '[' не первый в строке s */ \
               (int)(strchr(s,':')-strchr(s,'['))>=1 && /*  между '[' и '[' не менее одного символа */ \
               (int)(strchr(s,']')-strchr(s,':'))>=1 ) // между ';' и ']' не менее одного символа
//
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall tf_printf( char* str )
{ // вывод строки str во фрейм протокола + в файл fptrOut (global)
 t_printf( "%s", str );
 fprintf( fptrOut, "%s\n", str );
} // ----- конец tf_printf -----------------------------------------------------

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
bool __fastcall Process_Macros()
{ // читаем инструкции из файла FileNameSet, ищем заголОвки макросов, запоминаем
// тела макросов в mBody (тип TStringList), вызываем обработчик макросов и создаём
// новый файл с полным текстом (расщирения макросов)
 char str[_1024]="\0", strSave[_1024]="\0"; // строка для считывания и расшифровки инструкций + сохранение исходной строки
//
 flagMacroTitle_1D = flagMacroTitle_2D = false ; // !!!!!! вначале (global) !!!!!
//
 if( !(fptrIn = fopen( FileNameSet, "r") ) ) // файл fptrIn (global) открыть не удалось...
  return false;
//
 strcpy( FileNameSetPrP, ChangeFileExt(FileNameSet,ExtPrP).c_str() ); // имя файла инструкций после препроцессора
 if( !(fptrOut = fopen( FileNameSetPrP, "w") ) ) // файл инструкций после препроцессора fptrOut (global) открыть не удалось...
  return false;
//
////////////////////////////////////////////////////////////////////////////////
//
 for( INT i=0; i<max_Instruction; i++ ) // по строкам инструкций
  {
   if(fgets(str, sizeof(str), fptrIn) == NULL) // читаем строку из fptr
    break; // если строки кончились, функция fgets возвращает NULL
//
   strcpy( strSave, str ); // сохраним исходную строку
//
   if(str[strlen(str)-1] == 10) // если в конце символ новой строки (10) в десятичной)...
    str[strlen(str)-1] = ' ';   // ... то заменим на пробел !
//
// ----- все Tab в строке str заменяем на пробелы ------------------------------
   for( INT i=0; i<strlen(str); i++ ) // по всем символам строки...
    if( str[i] == VK_TAB ) // если i-тый символ есть Tab (9/0x9)...
     str[i] = VK_SPACE; // то заменяем его на пробел (32/0x20) !
//
   DSTA( str ); // чистка строки str от лидирующих и терминирующих Tabs и пробелов
//
   if( !strlen(str) || // если длина строки нулевая...
       str[0]==startComments[0] || // или строка начинается с ";"...
       str[0]==';' ) // частая описка ( ':' вместо ";" )
    goto cont;
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
  i_env_BypassMacro = setjmp( env_BypassMacro ); // установили точку перехода
  if( i_env_BypassMacro ) // не ноль - значит, сюда был прыжок !!!!!!!!!!!!!!!!!
   goto label_BypassMacro;
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
   if( !makeMassive_1D( str, i ) ||  // расширение макроса в 1D-псевдомассив
// continue; // строка str в выходной файл fptrOut добавляться не будет
       !makeMassive_2D( str, i ) ) // ...в 2D-псевдомассив
    continue; // строка str в выходной файл fptrOut добавляться не будет
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////
label_BypassMacro: // сюда переходим по longjmp --------------------------------
////////////////////////////////////////////////////////////////////////////////
cont: // для прОпуска строки с возможностью копирования в файл FileNameSetPrP --
////////////////////////////////////////////////////////////////////////////////
// ----- добавляем строки в выходной файл FileNameSetPrP -----------------------
 fputs( strSave, fptrOut ); // сохраняем строку исходного файла
//
 } // конец цикла i по строкам в файле FileNameSets
////////////////////////////////////////////////////////////////////////////////
//
 fclose( fptrIn  ); // закрываем все открытые файлы
 fclose( fptrOut );
//
 return 0; // всё Ok
//
} // --------- конец Process_Macros --------------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
bool __fastcall makeMassive_1D( char* str, INT i )
{ // находит и обрабатывает (расширяет) макрос в 1D-псевдомассивы --------------
// при возврате false строка str в выходной файл добавляться не будет ! --------
  if( !strncmp( str, "for[", 4 ) && // если в начале str находится 'for[' (первые 4 символа) 'и'
       sscanf( str, "for[%c]=%d,%d,%d{", &cI, &minI,&maxI,&dI ) == 4 ) // все 4 поля корректно прочитаны..!
  { // начало if( !strncmp( str, "for[", 4 ) && ...
//
   if( !dI || // неверен диапазон изменения переменных цикла (приводит к  беконечному повтору )
     (maxI>minI && dI<=0) || (maxI<minI && dI>=0) )
   {
    t_printf( "\n-M- Некорректен диапазон изменения [%d,%d,%d] переменной цикла '%c' -M-\n", minI,maxI,dI,cI );
    return false; // строка str в выходной файл fptrOut добавляться не будет
   }
//
   for_ID ++ ; // номер for[... в данной программе
   flagMacroTitle_1D = true; // нашли строку с заголовком 1D-макроса
//
   mBody->Clear(); // строки самого макроса
   mBody->Add( str ); // запомнили заголовок 1D-макроса
//
   mExpand->Clear(); // строки расширение макроса
   return false; // строка str в выходной файл fptrOut добавляться не будет
  } // конец if( !strncmp( str, "for[", 4 ) && ...
//
  if( flagMacroTitle_1D && str[0] != '}' ) // пока не было "}" в строке имеем flagMacroTitle=true
  {
   mBody->Add( str ); // добавляем в mBody строки макроса
   return false; // строка str в выходной файл fptrOut добавляться не будет
  }
//
  if( flagMacroTitle_1D && str[0] == '}' ) // после заголовка макроса в строке встретился "}"
  {
   flagMacroTitle_1D = false; // в строке встретился "}"
   mBody->Add( str ); // добавляем в mBody строку "}"
// endN = i; // запомним номер строки с последним символом макроса
//
////////////////////////////////////////////////////////////////////////////////
   SelectInstrForMacrosExpans_1D(); // выбор типа инструкции для расширения препроцессором
////////////////////////////////////////////////////////////////////////////////
   tf_printf( Format("; \n; начало расширения макроса: заголовок 'for[%s]=%d,%d,%d {'\n; for_ID: %d", // cI -> %s !!!
              OPENARRAY(TVarRec,(cI, int(minI), int(maxI),int(dI), int(for_ID)))).c_str() );
//
   for( int j=0; j<mBody->Count; j++ ) // исходный текст
    tf_printf( Format("; %s", OPENARRAY(TVarRec, (mBody->Strings[j].c_str()) )).c_str() );
//
   tf_printf( ";\n; начало расширение макроса на 1D псевдо-массивы" ); // добавим разделитель ";" и текст
//
   for( int j=0; j<mExpand->Count; j++ ) // добавление расширения на псевдо-массивы
    tf_printf( Format("%s",  OPENARRAY(TVarRec, (mExpand->Strings[j].c_str()) )).c_str() );
//
   tf_printf( Format("; \n; конец расширения макроса: заголовок 'for[%s]=%d,%d,%d {'\n;", // cI -> %s !!!
              OPENARRAY(TVarRec,(cI, int(minI),int(maxI),int(dI)))).c_str() );
////////////////////////////////////////////////////////////////////////////////
   return false; // строка str в выходной файл fptrOut добавляться не будет
  }
//
} // ------ конец makeMassive_1D -----------------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall replace_Str( char* s, const char* sOld, const char* sNew )
{ // все вхождения sOld (кроме как в именах стандартных функций stdFunc) в s заменяются на sNew
//
 string strTmp; // expr - глобальная !!!
//
// ------ замена stdFunc[] -----------------------------------------------------
 for( int i=0; i<sizeof(stdFunc)/sizeof(stdFunc[0]); i++ ) // по названиям стандартных функций парсера
 {
  strReplace( expr, sizeof(expr)-1, s, stdFunc[i], Format( replaceFmt,OPENARRAY(TVarRec,(i))).c_str() );
  strcpy( s, expr );
 } // конец for( int i=0; i<sizeof(stdFunc)/sizeof(stdFunc[0]); i++ )
//
 for( int ii=10; ii>=2; ii-- ) // проверка на наличие ii последовательных cI
  if( strstr( s, strTmp.assign(ii,cI).c_str() ) )
  {
   t_printf( "\n-M- В строке [%s] для вычислений встречен многократный (%d) повтор индекса '%c' -M-\n", s,ii,cI );
   longjmp( env_BypassMacro, 1 ); // нелокальный переход к точке setjmp !!!!!!!
  }
//
 strReplace( expr, sizeof(expr)-1, s, sOld, sNew ); // замена строки sOld на строку sNew (обычно cI на X[0])
//
 strcpy( s, expr ); // готовимся к восстанвлению строки ---------------------------
//
// ------ восстановление stdFunc[] ---------------------------------------------
 for( int i=0; i<sizeof(stdFunc)/sizeof(stdFunc[0]); i++ ) // по названиям стандартных функций парсера
 {
   strReplace( expr, sizeof(expr)-1, s, Format( replaceFmt,OPENARRAY(TVarRec,(i))).c_str(), stdFunc[i] );
   strcpy( s, expr );
 } // конец for( int i=0; i<sizeof(stdFunc)/sizeof(stdFunc[0]); i++ )
//
} // ------ конец replace_Str --------------------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
double __fastcall pcExpression( char* Expression, double Value_1, double Value_2 )
{ // парсеринг и вычисление выражения Expression от двух переменных Value_1/Value_2
//
 try
 {
  parser.Compile( Expression ); // разборка выражения
  parser.Evaluate( Value_1, Value_2 ); // точка вычисления по переменным X[0],X[1] etc
  return parser.GetResult(); // возвращаем double !!!
 }
 catch(TError error)
 {
  if( flagAlarmParser ) // выдать предупреждение (global)
  {
   MessageBeep( MB_OK ); // звуковое предупреждение...
   snprintf( str,sizeof(str), "ПРЕПРОЦЕССОР: проблема разборки выражения\n\n[%s]" // str - global
                              "\n\nОШИБКА: [%s] в позиции %d",
             Expression, error.error, error.pos );
   MessageBox(0, str, " Ошибка !", MB_OK);
//
   flagAlarmParser = false; // global..!
  } // и больше не выдавать..!
//
 } // конец catch( )
//
} // -------- конец pcExpression -----------------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
int __fastcall testIndex(char* str, char chr )
{ // если в строке str кроме БУКВЫ 'chr' встречаются и иные БУКВЫ, выдаётся число встреч
//
 int count = 0;
//
 for( int i=0; i<strlen(str); i++ ) // по всей строке str
  if( isalpha(str[i]) && str[i] !=chr ) // если БУКВА и НЕ 'chr'
   count++;
//
 return count;
//
} // ------ конец testIndex ----------------------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall SelectInstrForMacrosExpans_1D()
{ // выбор типа инструкции макроса для расширения препроцессором
//
 for( int j=1; j<mBody->Count-1; j++ ) // цикл по строкам содержания макроса (кроме заголовка и последней)
 {
  strncpy( SetName, mBody->Strings[j].c_str(), 3 ); // запомнили мнемонику инструкции (3 первых символа)
  strupr( SetName ); // переводим в заглавные для корректности сравнения
//
  if( !strcmp( SetName, "SET") ) // это SET ..!
   Expansion_SET_1D( mBody->Strings[j].c_str() ); // расширяет макрос по инструкции SET
  else // это не SET (1-2 операнда в инструкции)
   Expansion_1_2_Opd_1D( mBody->Strings[j].c_str(), Get_CountOperandsByInstruction( SetName ) );
 }
//
} // --------- конец SelectInstrForMacrosExpans_1D -----------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall SelectInstrForMacrosExpans_2D()
{ // выбор типа инструкции макроса для расширения препроцессором
//
 for( int j=1; j<mBody->Count-1; j++ ) // цикл по строкам содержания макроса (кроме заголовка и последней)
 {
  strncpy( SetName, mBody->Strings[j].c_str(), 3 ); // запомнили мнемонику инструкции (3 первых символа)
  strupr( SetName ); // переводим в заглавные для корректности сравнения
//
  if( !strcmp( SetName, "SET") ) // это SET ..!
   Expansion_SET_2D( mBody->Strings[j].c_str() ); // расширяет макрос по инструкции SET
  else // это не SET (1-2 операнда в инструкции)
   Expansion_1_2_Opd_2D( mBody->Strings[j].c_str(), Get_CountOperandsByInstruction( SetName ) );
 }
//
} // --------- конец SelectInstrForMacrosExpans_2D -----------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
bool __fastcall makeMassive_2D( char* str, INT i )
{ // находит и обрабатывает (расширяет) макрос в 2D-псевдомассивы --------------
//
  if( !strncmp( str, "for[", 4 ) && // если в начале str находится 'for[' (первые 4 символа) 'и'
       sscanf( str, "for[%c:%c]=%d,%d,%d:%d,%d,%d{", &cI,&cJ,&minI,&maxI,&dI, // все 8 полей корректно прочитаны..!
                                                             &minJ,&maxJ,&dJ ) == 8 )
  { // начало if( !strncmp( str, "for[", 4 ) && ...
//
   if( !dI || // неверен диапазон изменения переменных цикла I (приводит к беконечному повтору )
     (maxI>minI && dI<=0) || (maxI<minI && dI>=0) )
   {
    t_printf( "\n-M- Некорректен диапазон изменения [%d,%d,%d] переменной цикла '%c' -M-\n", minI,maxI,dI,cI );
    return false; // строка str в выходной файл fptrOut добавляться не будет
   }
//
   if( !dJ || // неверен диапазон изменения переменных цикла J (приводит к беконечному повтору )
     (  maxJ>=minJ && dJ<=0) || ( maxJ<=minJ && dJ>=0) )
   {
    t_printf( "\n-M- Некорректен диапазон изменения [%d,%d,%d] переменной цикла '%c' -M-\n", minJ,maxJ,dJ,cJ );
    return false;  // строка str в выходной файл fptrOut добавляться не будет
   }
//
   if( cI == cJ ) // одинаковые индексы обоих циклов
   {
    t_printf( "\n-M- Одинаковые индексы вложенных циклов - внешний: '%c' , внутренний: '%c' -M-\n", cI, cJ );
    return false;  // строка str в выходной файл fptrOut добавляться не будет
   }
//
   for_ID ++ ; // номер for[... в данной программе
   flagMacroTitle_2D = true; // нашли строку с заголовком 1D-макроса
//
   mBody->Clear(); // строки исходного макроса
   mBody->Add( str ); // запомнили заголовок 2D-макроса
//
   mExpand->Clear(); // строки расширения макроса
   return false;  // строка str в выходной файл fptrOut добавляться не будет
  } // конец if( !strncmp( str, "for[", 4 ) && ...
//
  if( flagMacroTitle_2D && str[0] != '}' ) // пока не было "}" в строке имеем flagMacroTitle=true
  {
   mBody->Add( str ); // добавляем в mBody строки макроса
   return false; // строка str в выходной файл fptrOut добавляться не будет
  }
//
  if( flagMacroTitle_2D && str[0] == '}' ) // после заголовка макроса в строке встретился "}"
  {
   flagMacroTitle_2D = false; // в строке встретился "}"
   mBody->Add( str ); // добавляем в mBody строку "}"
//
////////////////////////////////////////////////////////////////////////////////
   SelectInstrForMacrosExpans_2D(); // выбор типа инструкции для расширения препроцессором
////////////////////////////////////////////////////////////////////////////////
   tf_printf( Format("; \n; начало расширения макроса: заголовок 'for[%s:%s]=%d,%d,%d:%d,%d,%d {'\n; for_ID: %d", // cI -> %s !!!
              OPENARRAY(TVarRec,(cI,cJ, int(minI),int(maxI),int(dI), int(minJ),int(maxJ),int(dJ), int(for_ID)))).c_str() );
//
   for( int j=0; j<mBody->Count; j++ ) // исходный текст
    tf_printf( Format("; %s", OPENARRAY(TVarRec, (mBody->Strings[j].c_str()) )).c_str() );
//
   tf_printf( ";\n; начало расширение макроса на 2D псевдо-массивы" ); // добавим разделитель ";" и текст
//
   for( int j=0; j<mExpand->Count; j++ ) // добавление расширения на псевдо-массивы
    tf_printf( Format("%s",  OPENARRAY(TVarRec, (mExpand->Strings[j].c_str()) )).c_str() );
//
   tf_printf( Format("; \n; конец расширения макроса: заголовок 'for[%s:%s]=%d,%d,%d:%d,%d,%d {'\n;", // cI -> %s !!!
              OPENARRAY(TVarRec,(cI,cJ, int(minI),int(maxI),int(dI),  int(minJ),int(maxJ),int(dJ) ))).c_str() );
////////////////////////////////////////////////////////////////////////////////
    return false;  // строка str в выходной файл fptrOut добавляться не будет
  }
//
} // ------ конец makeMassive_2D -----------------------------------------------

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall Expansion_SET_1D( char* s )
{ // расширяет макрос по инструкции SET , добавляет расширение в mExpand (TStringList)
//
 int out;
 string strTmp;
 char *p, tmp_1[_512], tmp_2[_512]; // локальные массивы
//
// ----- разбираем 1-й операнд SET'а -------------------------------------------
//
  Comm[0] = '\0'; // обнуление...
//
  strcpy( str, s ); // копируем, ибо при обработке strtok исходная строка s разрушается
  strcpy( SetName,      p = strtok( str,  " " ) ); // мнемоника
  strcpy( Opd_1,   DAS( p = strtok( NULL, "," ) ) ); // 1-й операнд
  strcpy( Res,     DAS( p = strtok( NULL, ";" ) ) ); // результат
//
  strcpy( tmp_1,  Opd_1 ); // запомнили Opd_1
  strcpy( tmp_2,  Res ); // запомнили Res
//
  if( strchr(s,';') ) // если в строке есть ';'
   strcpy( Comm, &s[strchr(s,';')-s+1] ); // копируем в Comm всё правее ';'
//
 for( INT i=minI; i<=maxI; i+=dI ) // по всему заданному диапазону расширения макроса
 {
  strcpy( Opd_1, tmp_1 ); // восстановили Opd_1
  strcpy( Res,   tmp_2 ); // восстановили Res
//
  replace_Str( Opd_1, strTmp.assign(1,cI).c_str(), "X[0]" ); // замена cI на X[0] исключая имена стандартных функций
//
  sprintf( Opd_1, "%.*g", sizeof(Mem_Data[0].Addr)-1, pcExpression( expr, (double)i, 0.0 ) );
// ------ обрабатываем поле Res (результат выполнения инструкции) --------------
  if( test_isMassive_1D( Res ) )
   handlXXX_asMassive_1D( Res, i ); // обрабатываем результат, если он 1D-псевдомассив
  else
   handlXXX_asVariable_1D( Res, i ); // обрабатываем результат, если он простая переменная
//
// ---- собираем готовую строку инструкции из отдельных полей ------------------
//
  sprintf( str, "%s %s, %s ; %s", SetName, Opd_1, Res, Comm ); // готовим инструкцию для расширения
//
  mExpand->Add( str ); // добавим готовую инструкцию строку для временного хранения
//
 } // конец по i (по числу строк расширения) ===================================
//
} // ---------- конец Expansion_SET_1D -----------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall Expansion_SET_2D( char* s )
{ // расширяет макрос по инструкции SET , добавляет расширение в mExpand (TStringList)
//
 int out;
 string strTmp;
 char *p, tmp_1[_512], tmp_2[_512]; // локальные массивы
//
// ----- разбираем 1-й операнд SET'а -------------------------------------------
//
  Comm[0] = '\0'; // обнуление...
//
  strcpy( str, s ); // копируем, ибо при обработке strtok исходная строка s разрушается
  strcpy( SetName,      p = strtok( str,  " " ) ); // мнемоника
  strcpy( Opd_1,   DAS( p = strtok( NULL, "," ) ) ); // 1-й операнд
  strcpy( Res,     DAS( p = strtok( NULL, ";" ) ) ); // результат
//
  strcpy( tmp_1, Opd_1 ); // запомниди Opd_1
  strcpy( tmp_2, Res ); // запомнили Res
//
  if( strchr(s,';') ) // если в строке есть ';'
   strcpy( Comm, &s[strchr(s,';')-s+1] ); // копируем в Comm всё правее ';'
//
 for( INT i=minI; i<=maxI; i+=dI ) // по всему заданному диапазону i расширения макроса
 for( INT j=minJ; j<=maxJ; j+=dJ ) // по всему заданному диапазону j расширения макроса
 {
  strcpy( Opd_1, tmp_1 ); // восстановили Opd_1
  strcpy( Res,   tmp_2 ); // восстановили Res
//
  replace_Str( Opd_1, strTmp.assign(1,cI).c_str(), "X[0]" ); // замена cI на X[0] исключая имена стандартных функций
  replace_Str( Opd_1, strTmp.assign(1,cJ).c_str(), "X[1]" ); // замена cJ на X[1] ...
//
  sprintf( Opd_1, "%.*g", sizeof(Mem_Data[0].Addr)-1, pcExpression( expr, (double)i, double(j) ) ); // Оpd_1, w - глобал..1
// ------ обрабатываем поле Res (результат выполнения инструкции) --------------
  if( test_isMassive_2D( Res ) )
   handlXXX_asMassive_2D( Res, i, j ); // обрабатываем результат, если он 2D-псевдомассив
  else
   handlXXX_asVariable_2D( Res, i, j ); // обрабатываем результат, если он простая переменная
//
// ---- собираем готовую строку инструкции из отдельных полей ------------------
  sprintf( str, "%s %s, %s ; %s", SetName, Opd_1, Res, Comm ); // готовим преобразованную строку инструкции
////////////////////////////////////////////////////////////////////////////////
  mExpand->Add( str ); // добавим готовую строку расширения для сохранения
//
 } // конец по i,j (по числу строк и столбцов расширения) ======================
//
} // ---------- конец Expansion_SET_2D -----------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall Expansion_1_2_Opd_1D( char* s, int nOpd )
{ // расширяет макрос по инструкции c 1-2 операндами , добавляет расширение в
// mExpand (TStringList) ; nOpd - число операндов
// bool outCode = true; // удачное расширение SET
 boolean isPred; // есть ли в не P-операторе предикат
 char *p, *n, *ps, *pe, tmp[_512],
      tmp_1[_512], tmp_2[_512], tmp_3[_512], tmp_4[_512]; // локальные массивы для компонентов машинной инструкции
//
  strcpy( str, s ); // копируем, ибо при обработке strtok исходная строка s разрушается
//
  Opd_2[0] = Comm[0] = '\0'; // обнуление...
//
  strcpy( SetName,    p = strtok( str,  " " ) ); // мнемоника
  strcpy( Opd_1, DAS( p = strtok( NULL, "," ) ) ); // 1-й операнд
//
  if( nOpd == 2 )
   strcpy( Opd_2, DAS( p = strtok( NULL, "," ) ) ) ; // 2-й операнд
//
// ----- ищем разницу при использовании поля предиката в P- и не-P-инстукциях---
  if( is_Predicat( SetName ) ) // оператор SetName = P-инструкция)
   strcpy( Res, DAS( p = strtok( NULL, ";" ) ) ); // результат (используемый в будущем как предикат)
  else // не P-инструкция
  {
   strcpy( Res,  DAS( p = strtok( NULL, ",;" ) ) ); // результат инструкции
   strcpy( str, s ); // восстановили, ибо при обработке strtok исходная строка s разрушается
   n = strstr( str, Res ); // начало p в str
   n += strlen(Res); // первый символ после Res в str
//
   strcpy( tmp, str+(n-str) ); // tmp<-str (str начиная с n и до конца str) ; tmp - для упрощения
//
   if( ps=strchr( tmp, ',') ) // символ ',' в temp найден - значит, предикат имеется..!
   {
    isPred = true;
    pe=strchr( tmp, ';'); // найден ';'
    strncpy( Pred, tmp+1, pe-tmp-1 ); // Pred<-tmp (tmp начиная с 1 и до pe-tmp-1)
    DAS( Pred );
   } // конец if( ps=strchr( tmp, ',') )
//
   else
   if( strchr( tmp, ';') ) // символ ';' в temp найден - значит, поля предиката нет..!
   {
    isPred = false;
    Pred[0] = '\0';
   }
//
  } // конец else if( is_Predicat( SetName ) )
//
  if( strchr(s,';') ) // если в строке есть ';'
   strcpy( Comm, &s[strchr(s,';')-s+1] ); // копируем в Comm всё, правее ';'
//
  strcpy( tmp_1, Opd_1 ); // сохраняем компоненты машинной инструкции
  strcpy( tmp_2, Opd_2 );
  strcpy( tmp_3, Res );
  strcpy( tmp_4, Pred );
//
 for( INT i=minI; i<=maxI; i+=dI ) // по заданному i-диапазону расширения 1D-макроса
 {
// ----- разбираем операнды не SET'а -------------------------------------------
  strcpy( Opd_1, tmp_1 ); // востанавливаем компоненты машинной инструкции
  strcpy( Opd_2, tmp_2 );
  strcpy( Res,   tmp_3 );
  strcpy( Pred,  tmp_4 );
//
// ------ обрабатываем поле Opd_1 (первый операнд инструкции) ------------------
  if( test_isMassive_1D( Opd_1 ) )
   handlXXX_asMassive_1D( Opd_1, i ); // обрабатываем результат, если он 1D-псевдомассив
  else
   handlXXX_asVariable_1D( Opd_1, i ); // обрабатываем результат, если он простая переменная
//
// ------ обрабатываем поле Opd_2 (второй операнд инструкции) ------------------
  if( nOpd == 2 ) // 2-й операнд
   if( test_isMassive_1D( Opd_2 ) )
    handlXXX_asMassive_1D( Opd_2, i ); // обрабатываем результат, если он 1D-псевдомассив
   else
    handlXXX_asVariable_1D( Opd_2, i ); // обрабатываем результат, если он простая переменная
//
// ------ обрабатываем поле Pred (предикат) ------------------------------------
  if( strlen( Pred ) ) // если предикат присутствует...
   if( test_isMassive_1D( Pred ) )
    handlXXX_asMassive_1D( Pred, i ); // обрабатываем результат, если он 1D-псевдомассив
   else
    handlXXX_asVariable_1D( Pred, i ); // обрабатываем результат, если он простая переменная
//
// ------ обрабатываем поле Res (результат выполнения инструкции) --------------
  if( test_isMassive_1D( Res ) )
   handlXXX_asMassive_1D( Res, i ); // обрабатываем результат, если он 1D-псевдомассив
  else
   handlXXX_asVariable_1D( Res, i ); // обрабатываем результат, если он простая переменная
//
// ---- собираем готовую строку инструкции из отдельных полей ------------------
  if( nOpd == 1 ) // 1 операнд в инструкции
   isPred ? sprintf( str, "%s %s, %s, %s ; %s", SetName, Opd_1, Res, Pred, Comm )
          : sprintf( str, "%s %s, %s ; %s",     SetName, Opd_1, Res,       Comm ) ;
  else // 2 операнда в инструкции
   isPred ? sprintf( str, "%s %s, %s, %s, %s ; %s", SetName, Opd_1, Opd_2, Res, Pred, Comm )
          : sprintf( str, "%s %s, %s, %s ; %s",     SetName, Opd_1, Opd_2, Res,       Comm ) ;
////////////////////////////////////////////////////////////////////////////////
//
  mExpand->Add( str ); // добавим готовую строку расширения для сохранения в nExpand
//
 } // конец цикла по i
//
} // ---------- конец Expansion_1_2_Opd_1D -------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall Expansion_1_2_Opd_2D( char* s, int nOpd )
{ // расширяет макрос по инструкции c 1-2 операндами , добавляет расширение в
// mExpand (TStringList) ; nOpd - число операндов
// bool outCode = true; // удачное расширение SET
 boolean isPred; // есть ли в не P-операторе предикат
 char *p, *n, *ps, *pe, tmp[_512],
      tmp_1[_512], tmp_2[_512], tmp_3[_512], tmp_4[_512]; // локальные массивы для компонентов машинной инструкции
//
  strcpy( str, s ); // копируем, ибо при обработке strtok исходная строка s разрушается
//
  Opd_2[0] = Comm[0] = '\0'; // обнуление...
//
  strcpy( SetName,      p = strtok( str,  " " ) ); // мнемоника
  strcpy( Opd_1,   DAS( p = strtok( NULL, "," ) ) ); // 1-й операнд
//
  if( nOpd == 2 )
   strcpy( Opd_2,  DAS( p = strtok( NULL, "," ) ) ) ; // 2-й операнд
//
// ----- ищем разницу при использовании поля предиката в P- и не-P-инстукциях---
  if( is_Predicat( SetName ) ) // оператор SetName = P-инструкция)
   strcpy( Res, DAS( p = strtok( NULL, ";" ) ) ); // результат (используемый в будущем как предикат)
  else // не P-инструкция
  {
   strcpy( Res,  DAS( p = strtok( NULL, ",;" ) ) ); // результат инструкции
   strcpy( str, s ); // восстановили, ибо при обработке strtok исходная строка s разрушается
   n = strstr( str, Res ); // начало p в str
   n += strlen(Res); // первый символ после Res в str
//
   strcpy( tmp, str+(n-str) ); // tmp<-str (str начиная с n и до конца str) ; tmp - для упрощения
//
   if( ps=strchr( tmp, ',') ) // символ ',' в temp найден - значит, предикат имеется..!
   {
    isPred = true;
    pe=strchr( tmp, ';'); // найден ';'
    strncpy( Pred, tmp+1, pe-tmp-1 ); // Pred<-tmp (tmp начиная с 1 и до pe-tmp-1)
    DAS( Pred );
   } // конец if( ps=strchr( tmp, ',') )
//
   else
   if( strchr( tmp, ';') ) // символ ';' в temp найден - значит, поля предиката нет..!
   {
    isPred = false;
    Pred[0] = '\0';
   }
//
  } // конец else if( is_Predicat( SetName ) )
//
  if( strchr(s,';') ) // если в строке есть ';'
   strcpy( Comm, &s[strchr(s,';')-s+1] ); // копируем в Comm всё, правее ';'
//
  strcpy( tmp_1, Opd_1 ); // сохраняем компоненты машинной инструкции
  strcpy( tmp_2, Opd_2 );
  strcpy( tmp_3, Res );
  strcpy( tmp_4, Pred );
//
 for( INT i=minI; i<=maxI; i+=dI ) // по заданному i-диапазону расширения 2D-макроса
 for( INT j=minJ; j<=maxJ; j+=dJ ) // по заданному j-диапазону расширения 2D-макроса
 {
  strcpy( Opd_1, tmp_1 );  //восстанавливаем компоненты машинной инструкции
  strcpy( Opd_2, tmp_2 );
  strcpy( Res,   tmp_3 );
  strcpy( Pred,  tmp_4 );
//
// ------ обрабатываем поле Opd_1 (первый операнд инструкции) ------------------
  if( test_isMassive_2D( Opd_1 ) )
   handlXXX_asMassive_2D( Opd_1, i, j ); // обрабатываем результат, если он 1D-псевдомассив
  else
   handlXXX_asVariable_2D( Opd_1, i, j ); // обрабатываем результат, если он простая переменная
//
// ------ обрабатываем поле Opd_2 (второй операнд инструкции) ------------------
  if( nOpd == 2 ) // 2-й операнд
   if( test_isMassive_2D( Opd_2 ) )
    handlXXX_asMassive_2D( Opd_2, i, j ); // обрабатываем результат, если он 2D-псевдомассив
   else
    handlXXX_asVariable_2D( Opd_2, i, j ); // обрабатываем результат, если он простая переменная
//
// ------ обрабатываем поле Pred (предикат) ------------------------------------
  if( strlen( Pred ) ) // если предикат присутствует
   if( test_isMassive_1D( Pred ) )
    handlXXX_asMassive_1D( Pred, i ); // обрабатываем результат, если он 1D-псевдомассив
   else
    handlXXX_asVariable_1D( Pred, i ); // обрабатываем результат, если он простая переменная
//
////////////////////////////////////////////////////////////////////////////////
// ------ обрабатываем поле Res (результат выполнения инструкции) --------------
  if( test_isMassive_2D( Res ) )
   handlXXX_asMassive_2D( Res, i, j ); // обрабатываем результат, если он 2D-псевдомассив
  else
   handlXXX_asVariable_2D( Res, i, j ); // обрабатываем результат, если он простая переменная
//
// ---- собираем готовую строку инструкции из отдельных полей ------------------
// ---- собираем готовую строку инструкции из отдельных полей ------------------
  if( nOpd == 1 ) // 1 операнд в инструкции
   isPred ? sprintf( str, "%s %s, %s, %s ; %s", SetName, Opd_1, Res, Pred, Comm )
          : sprintf( str, "%s %s, %s ; %s",     SetName, Opd_1, Res,       Comm ) ;
  else // 2 операнда в инструкции
   isPred ? sprintf( str, "%s %s, %s, %s, %s ; %s", SetName, Opd_1, Opd_2, Res, Pred, Comm )
          : sprintf( str, "%s %s, %s, %s ; %s",     SetName, Opd_1, Opd_2, Res,       Comm ) ;
////////////////////////////////////////////////////////////////////////////////
  mExpand->Add( str ); // добавим готовую строку расширения для сохранения
//
 } // конец цикла по i,j (по числу строк и столбцов расширения) ================
//
} // ---------- конец Expansion_1_2_Opd_2D -------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall handlXXX_asMassive_2D( char* Field, INT i, INT j )
{ // обрабатываем поле XXX=Field типа Opd_1,Opd_2,Res для 2D-псевдомассивов ----
//
  string strTmp;
  char *p, tmp_1[_512],tmp_2[_512], expr_1[_512],expr_2[_512]; // локальные массивы
//
  strcpy( nameMass,    p = strtok( Field,  "[" ) ); // строка до '['
  strcpy( indexMass_1, p = strtok( NULL,    ":" ) ); // строка от '[' до ':'
  strcpy( indexMass_2, p = strtok( NULL,   "]" ) ); // строка от ':' до ']'
//
  if( !permissName( nameMass ) )
  { // проверка на допустИмость имени массива (длина > 0 символов и начальный символ БУКВА)
   t_printf( err_01, Field );
   longjmp( env_BypassMacro, 1 ); // нелокальный переход к точке setjmp !!!!!!!
  }
//
  strReplace( tmp_1,  sizeof(tmp_1)-1,  indexMass_1, strTmp.assign(1,cI).c_str(), "X[0]" ); // замена в indexMass_1 строки cI на X[0]
  strReplace( expr_1, sizeof(expr_1)-1, tmp_1,       strTmp.assign(1,cJ).c_str(), "X[1]" ); // замена строки cJ на X[1]
//
  strReplace( tmp_2,  sizeof(tmp_2)-1,  indexMass_2, strTmp.assign(1,cI).c_str(), "X[0]" ); // замена в indexMass_2 строки cI на X[0]
  strReplace( expr_2, sizeof(expr_2)-1, tmp_2,      strTmp.assign(1,cJ).c_str(), "X[1]" ); // замена строки cJ на X[1]
//
  sprintf( Field, "%s[%d:%d]", nameMass, (INT)pcExpression( expr_1, (double)i, (double)j ),
                                         (INT)pcExpression( expr_2, (double)i, (double)j ) );
//
} // ----- конец handlXXX_asMassive_2D -----------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall handlXXX_asMassive_1D( char* Field, INT i )
{ // обрабатываем поле XXX=Field типа Opd_1,Opd_2,Pred,Res для 1D-псевдомассивов
//
  string strTmp;
  char *p;
//
  strcpy( nameMass,  p = strtok( Field, "[" ) ); // строка до '['
  strcpy( indexMass, p = strtok( NULL,  "]" ) ); // строка от '[' до ']'
//
  if( !permissName(nameMass) )
  { // проверка на допустИмость имени массива (длина > 0 символов и начальный символ БУКВА)
   t_printf( err_01, Field );
   longjmp( env_BypassMacro, 1 ); // нелокальный переход к точке setjmp !!!!!!!
  }
//
  strReplace( expr, sizeof(expr)-1, indexMass, strTmp.assign(1,cI).c_str(), "X[0]" ); // замена строки cI на X[0]
//
  sprintf( Field, "%s[%d]", nameMass, (INT)pcExpression( expr, (double)i, 0.0 ) );
//
} // ----- конец handlXXX_asMassive_1D -----------------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall handlXXX_asVariable_1D( char* Field, INT i )
{  // обрабатываем поле XXX=Field типа Opd_1,Opd_2,Pred,Res для 1D-псевдомассивов
// обрабатываеи поле операнда, если он в форме простой переменной
//
 if( TokenUse && (&Field==&Res) ) // использовать токен для имени поля результата
  strcpy( Field, Format("%s:%d:%d",OPENARRAY(TVarRec,(Field,int(for_ID),int(i)) ) ).c_str() );
//
} // ---------- конец handlXXX_asVariable_1D -----------------------------------


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall handlXXX_asVariable_2D( char* Field, INT i, INT j )
{ // обрабатываем поле XXX=Field типа Opd_1,Opd_2,Pred,Res для 2D-псевдомассивов
//
 if( TokenUse && (&Field==&Res) ) // использовать токен для имени поля результата
  strcpy( Field, Format("%s:%d:%d:%d",OPENARRAY(TVarRec,(Field,int(for_ID),int(i),int(j)) ) ).c_str() );
//
} // ---------- конец handlOpd_asVariable_2D -----------------------------------




