
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
int __fastcall RunPreProcessor()
{ // препроцессор для конвертации макросов в инструкции
 char str[_512]="\0", // строка для считывания и расшифровки инструкций
      tmp[_512]="\0", // рабочая строка
      sIndex[2]="?\0", // символ индекса одномерного массива
      chr;
//      Set[_SET_LEN], // мнемоника инструкции
//      startFor1[] = "for[", // маска для поиска начала описания макросов цикла
//      fmtFor1[]   = "for[%c]=%d,%d,%d;"; // формат выявления начала макроса цикла
//
 int minI,maxI,stepI; // диапазон индексов одномерного цикла
//
 strcpy( FileNameSetPrP, ChangeFileExt(FileNameSet,ExtPrP).c_str() ); // имя файла инструкций после препроцессора
//
 if( !(fptrIn  = fopen( FileNameSet,    "r") ) || // исходный файл инструкций открыть не удалось... ИЛИ
     !(fptrOut = fopen( FileNameSetPrP, "w") ) ) // файл инструкций после препроцессора открыть не удалось...
  return -1;
//
 if( !mPM )
  mPM = new TStringList(); // создали PM (набор строк для тела исходного макро)
//
 snprintf( tmp,sizeof(tmp), " Препроцессинг..." ); // вывод в строку статуса
 SBM2->Text = tmp;
//
 while( 1 ) // по всем строкам инструкций в исходном файле =====================
 {
  if( fgets(str, sizeof(str), fptrIn) == NULL ) // читаем строку из fptrIn
   break; // если строки кончились, функция fgets возвращает NULL
//
  DelSpacesTabsAround(str); // чистка строки str от лидирующих и терминирующих пробелов ...
//
// =============================================================================
  if( strncmp( str, "for[", 4 ) ) // если в начале str не "for[" (первые 4 символа)
  {
   fputs( str, fptrOut );  // пишем в fptrOut
   continue; // уходим на повтор while( 1 ) ====================================
  }
// остались строки с "for[" (первые 4 символа) в начале.........................
//
// ----- пытаемся прочитать первую строку описания параметров одномерного массива
//
  if( sscanf( str, "for[%c]=%d,%d,%d {", sIndex,&minI,&maxI,&stepI ) != 4 ) // не все 4 полей корректно прочитаны..!
  {
   fputs( str, fptrOut );  // пишем в fptrOut
   continue; // уходим на повтор цикла while( 1 ) ==============================
  }
//
// чистим строку от ненужностей ................................................
//
  if(str[strlen(str)-1] == 10) // если в конце символ новой строки (10) в десятичной)...
   str[strlen(str)-1] = '\0';   // ... то заменим на КОНЕЦ СТРОКИ !
//
  if(!strlen(str)) // если длина нулевая - просто пропускаем ее !
   continue; // повтор цикла while( 1 ) ========================================
//
  if( str[0] == startComments[0] ) // если строка начинается с комментария - просто пропускаем ее !
   continue;
//
// а вот теперь всё верно..! Начинаем анализировать содержиое строк между "for[c]=n1,n2.n3 {" и "}"
//
// ----- проверки корректности значений sIndex,minI,maxI,stepI -----------------
  startPos[0] = '\0'; // строки выводятся без комментариев
  if( minI >= maxI && stepI == 0 )
   startPos[0] = startComments[0]; // все строки комментируются
//
cont_withim_macros_body: // начинаем цикл по строкам тела макроса --------------
//
  if( fgets(str, sizeof(str), fptrIn) == NULL ) // читаем строку из fptrIn
   goto enf_of_fptrIn; // выход из цикла while( 1 ) ============================
//
   if( str[0] == '}' ) // это конец тела макроса -------------------------------
   {
// тут была отладочная печать --------------------------------------------------
   }
   else // это ещё не конец тела for[]...
   {
    if(str[strlen(str)-1] == 10) // если в конце символ новой строки (10) в десятичной)...
     str[strlen(str)-1] = '\0';   // ... то заменим на КОНЕЦ СТРОКИ !
//
    DelSpacesTabsAround(str); // чистка строки str от лидирующих и терминирующих пробелов ...
//
    if( str[0] != startComments[0] && strlen( str ) ) // комментированные или пустые строки тела макроса не добавляем в PM
     mPM->Add( str ); // добавили в PM
    goto cont_withim_macros_body; // идём на считывание новой строки тела макроса
   }
//
enf_of_fptrIn: // конец входного файла fptrIn ----------------------------------
//
  fprintf( fptrOut, "%c%c start pre-prosessor (PrP) the 1D-cycle \"for[%s]=%d,%d,%d\"\n",
                    startComments[0],startComments[0], sIndex,minI,maxI,stepI );
//
  for( int iRow=0; iRow<mPM->Count; iRow++ ) // по всем строкам в PM
  {
   fprintf( fptrOut, "%c%c %s %c source line (before PreP)\n", startComments[0],startComments[0],
                     mPM->Strings[iRow].c_str(), startComments[0] );
//
   for( int i=minI; i<=maxI; i+=stepI ) // для каждого значения параметра цикла
    PreProcRow_For1( iRow, sIndex, i ); // расширяем строку iRow тела макроса
//
  } // конец цикла while( 1 ) ==================================================
//
// ---- выводим преобразованные данные -----------------------------------------
  fprintf( fptrOut, "%c%c end pre-prosessor (PrP) the 1D-cycle \"for[%s]=%d,%d,%d\"\n",
                    startComments[0],startComments[0], sIndex,minI,maxI,stepI );
//
  mPM->Clear(); // очистить PM (TStringList) после обработки очередного макроса

////////////////////////////////////////////////////////////////////////////////
//
 } // конец цикла for( UI i=0; ; i++ ) по всем строкам инструкций в исходном файле
//
 fclose( fptrIn  ); // закрываем все открытые файлы
 fclose( fptrOut );
//
 return 0; // всё Ok
//
} // ---------- конец RunPreProcessor ------------------------------------------

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
char* __fastcall ParseAndCalculateIndex(char* Expression)
{ // парсеринг и вычисление выражения (без параметров) Expression
 char str[_128]="\0";
//
 try
 {
  parser.Compile( Expression ); // разборка выражения
  parser.Evaluate( 0.0 ); // значение использоваться не будет, но должно присутствовать
  strcpy( str, IntToStr( int( parser.GetResult() )).c_str() ); // возвращаем ВСЕГДА ЦЕЛОЕ в виде строки !!!
  return str;
 }
 catch(TError error)
 {
  if( flagAlarmParser ) // выдать предупреждение...
  {
   MessageBeep( MB_OK ); // звуковое предупреждение...
   snprintf( str,sizeof(str), "Препроцессор: проблема разборки выражения\n\n%s\n\nошибка %s в позиции %d", Expression, error.error, error.pos );
   MessageBox(0, str, "Ошибка !", MB_OK);
//
   flagAlarmParser = false;
  } // и больше не выдавать..!
//
  startPos[0] = startComments[0]; // после ошибки все строки комментируются ";"
//
 } // конец catch( )
//
} // -------- конец ParseAndCalculateIndex -------------------------------------

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
int __fastcall PreProcRow_For1( INT iRow, char* sIndex, INT iCycle )
{ // препроцессор для конвертации одной строки тела макроса одномерного массива
// здесь iRow - номер строки исходного тела макроса (из RM),
// sIndex - строка индекса одномерного массива, iCycle - номер цикла
 char str[_512]="\0",
      tmp[_256]="\0",
      dest[_256]="\0",
      w[_512]="\0", *p,
      *pStartSB, *pEndSB, // указатели на '[' и ']' (Start Square Brecket - End Square Brecket)
      work[_512]="\0", // работаем с внешней рабочей строкой (в ней будем НАКАПЛИВАТЬ) преобразованные части обрабатываемой строки
      buff[_512]="\0", // рабочий буффер для work
      ch[2] = "?\0";
 INT  Start=0, i, // начиная с какого символа в str ищем [хххх]
      lenOld=strlen(sIndex);
//
 strcpy( str, mPM->Strings[iRow].c_str() ); // эту строку тела макроса будем конвертировать
//
 for( i=1; ; i++ ) // поиск всех вхождений шаблона [хххх]
 {
  if( p = strchr(str,startComments[0]) ) // если есть символ начала комментария (символ startComments[0])...
   str[ p-str ] = '\0'; // убираем комментарии вместе с этим символом..!
//
  pStartSB = strstr( &str[ Start ], "[\0" ); // p_Start указатель на символ '[' (ищем начиная с позиции Start)
  if( !pStartSB ) // не найдено p_Start - первого начиная с Start
   break; // цикл по j (внутренний)
//
  pEndSB = strstr( &str[ pStartSB-str ], "]\0" ); // p_End указатель на символ ']' (ищем начиная с последнего '[')
//
// итак, у нас '[' в позиции p_Start-Start и ']' в позиции p_End-Start ---------
// подстроку без с '[' и ']' копируем во временный буфер w ------------------
  strncpy( tmp, &str[ pStartSB+1-str ], pEndSB-pStartSB ); // на единицу больше - чтобы поместилось '\0'
  tmp[ pEndSB-pStartSB-1 ] = '\0'; // добавили '\0' - strncat часто работает некоррректно
//
// теперь можем заменить все вхождения sIndex на IntToStr(iCycle) в строке w ---
  strReplace( dest, sizeof(dest)-1, tmp, sIndex, IntToStr(iCycle).c_str() );
//
// вычислили выражение БЕЗ ПАРАМЕТРОВ в строке w -------------------------------
  strcpy( tmp, ParseAndCalculateIndex( dest ) );
// добавляем в work часть str от Start до p_Start (включая '[') ----------------
  strncat( work, &str[ Start ], pStartSB-str-Start + 1 ); // прибавим 1, чтобы поместился '\0'
// часть str от Start до первого символа слева от '[' прибавляем в work --------
  strcat( work, tmp );
// добавим ']', ибо его в w не заносили ----------------------------------------
  strcat( work, "]\0" );
// новый цикл ( i ) поиска '[...]' начинаем c символа номер Start в строке str
  Start = pEndSB - str + 1 ;
//
////////////////////////////////////////////////////////////////////////////////
 } // конец for( i=1; ; i++ ) = цикл по числу вхождений '[...]'
//
 strcpy( str, work ); // заменим исходную строку для возврата
//
 DelSpacesTabsAround( str ); // чистка строки str от лидирующих и терминирующих пробелов ...
//
 strcpy( buff, str ); // запомнили str в буфере buff
//
////////////////////////////////////////////////////////////////////////////////
// обработка операнда команды SET ----------------------------------------------
////////////////////////////////////////////////////////////////////////////////
//
 strncpy( tmp, str, 3 ); // скопировали первые три символа str в tmp
 tmp[3] = '\0' ; // добавили конец строки после SET (иногда strncpy срабатывает некорректно)
//
 if( is_SET( strupr(tmp) ) ) // это инструкция SET..
 {
  strcpy( work, "SET " ); // начали готовить временную строку work
//
  p = strtok( str, " " ); // ищем входение первого пробела за SET
  p = strtok( NULL, ", " ); // ищем вхождение ',' после 1-го операнда
  strcpy( tmp, p ); // в tmp первый операнд SET

//  strcpy( str, mPM->Strings[iRow].c_str() ); // восстановим str после применения strtok
  strcpy( str, buff ); // восстановим str после применения strtok
//
  strReplace( dest, sizeof(dest)-1, tmp, sIndex, IntToStr(iCycle).c_str() ); // заменяем символ индекса его значением
  strcpy( tmp, ParseAndCalculateIndex( dest ) ); // вычисляем это значение
//
  strcat( work, tmp ); // добавили в work
  strcat( work, "," ); // добавили запятую и пробел
//
  strcpy( str, buff ); // восстановим str после применения strtok
//
  p = strtok( str, "," ); // ищем начало вхождение результата инструкции SET
//
  snprintf( w, sizeof(w), "%s%s", startComments,startComments ); // в w теперь ";;"
  p = strtok( NULL,  w ); // ищем конец вхождения инструкции SET (без комментариев)
//
  strcat( work, " " ); // пробел перед результатом операции SET
  strcat( work, p ); // адрес результата
//
  strcpy( str, work ); // всё готово - результат снова в str
//
 } // конец обработки инструкции SET -------------------------------------------
//
 fprintf( fptrOut, "%s%s %s line after PrP\n", startPos, str, startComments );
// fputs( " ; line after PrP\n", fptrOut );
//
 return 0; // всё Ok
//
} // --------- конец PreProcRow_For1 -------------------------------------------


